<chapter>
  <title>Usage of Coding Standards for C#</title>
  <para>
    <superscript>
      <emphasis>Requirement: CREQ0001; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-30 21:04:00Z; Modified: 2015-11-30 21:20:05Z.</emphasis>
    </superscript>
  </para>
  <section>
    <title>Introduction</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0002; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-30 21:06:10Z; Modified: 2019-11-02 12:25:22Z.</emphasis>
      </superscript>
    </para>
    <para>There are two aspects to coding standards:</para>
    <itemizedlist>
      <listitem>
        <para>Guidelines to assist developers in reading and identifying code, especially in teams of two or more developers. This assists developers in better understanding the intentions of others.</para>
      </listitem>
      <listitem>
        <para>Applying design patterns. By documenting lessons learned in previous projects, the application of design patterns can improve code readability, design and reduce the chance of defects by less experienced developers.</para>
      </listitem>
    </itemizedlist>
    <para>Where possible, coding standards should also include rationale, to help assist developers in understanding <emphasis>why</emphasis> such a coding standard exists and how it is intended to benefit the project.</para>
    <para>These coding standards use the text <emphasis role="bold">Rationale </emphasis>to explain any reasoning behind decisions in implementation. This also encourages developers to decide on a more appropriate guideline, or to decide the circumstances under which a guideline should be applied. It also challenges the author of such a guideline to justify the means for a restriction on the writing of code, which may lead to a more solid foundation of the guidelines, or an update improving the guidelines themselves.</para>
    <para>Keywords and coding words are in bold, such as <emphasis role="bold">return</emphasis>, <emphasis role="bold">IEnumerable</emphasis>, etc.</para>
  </section>
  <section>
    <title>New Projects</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0003; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-30 21:04:49Z; Modified: 2015-11-30 21:05:12Z.</emphasis>
      </superscript>
    </para>
    <para>New project should strive to conform to this set of coding standards where it's mandated.</para>
  </section>
  <section>
    <title>Existing Projects</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0004; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-30 21:05:16Z; Modified: 2015-11-30 21:05:53Z.</emphasis>
      </superscript>
    </para>
    <para>Coding standards for existing projects should be maintained. That is, do not rewrite large chunks of code simply because it doesn't conform to the coding standards. Adhere to the standards that are in use for that project.</para>
  </section>
  <section>
    <title>Revision History</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0186; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-01 21:40:30Z; Modified: 2019-11-01 21:40:34Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Version 1.0.0 (2016-07-31)</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0188; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-01 21:42:38Z; Modified: 2019-11-01 21:43:31Z.</emphasis>
        </superscript>
      </para>
      <para>Initial version of the coding standards, taken from various sources and experience from code reviews.</para>
    </section>
    <section>
      <title>Version 1.1.0 (2018-06-04)</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0189; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-01 21:43:36Z; Modified: 2019-11-01 21:55:30Z.</emphasis>
        </superscript>
      </para>
      <para>Following changes</para>
      <itemizedlist>
        <listitem>
          <para>CREQ0012: Change constants to have no prefix</para>
        </listitem>
        <listitem>
          <para>CREQ0029: A title "Ordering" without content</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para>CREQ0070: Title change to SafeHandles</para>
        </listitem>
        <listitem>
          <para>CREQ0071: Added rationale for SafeHandles</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para>CREQ0103: The Model, and design principles</para>
        </listitem>
        <listitem>
          <para>CREQ0105: NUnit Test Framework should be used instead of MSTest</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para>CREQ0137: Define pseudo constants (private static readonly variables)</para>
        </listitem>
        <listitem>
          <para>CREQ0129: Implementing a Singleton in C#</para>
        </listitem>
        <listitem>
          <para>CREQ0130: Critical Sections and subsection</para>
        </listitem>
        <listitem>
          <para>CREQ0135: Optional Parameters and subsection</para>
        </listitem>
        <listitem>
          <para>CREQ0138: Abstract classes</para>
        </listitem>
        <listitem>
          <para>CREQ0142: Null conditional operator, do not use for event handlers</para>
        </listitem>
        <listitem>
          <para>CREQ0148: Use of nameof keyword</para>
        </listitem>
        <listitem>
          <para>CREQ0149: Don't use named parameters</para>
        </listitem>
        <listitem>
          <para>CREQ0150: SafeHandle and DangerousGetHandle</para>
        </listitem>
      </itemizedlist>
      <itemizedlist>
        <listitem>
          <para>CREQ0151: Avoid side effects in construction</para>
        </listitem>
        <listitem>
          <para>CREQ0152: Use AccessorBase implementation</para>
        </listitem>
        <listitem>
          <para>CREQ0156: Single Responsibility Principle</para>
        </listitem>
        <listitem>
          <para>CREQ0158: Virtual protected methods for Events</para>
        </listitem>
        <listitem>
          <para>CREQ0159: Don't use Enum.HasFlag</para>
        </listitem>
        <listitem>
          <para>CREQ0160: Argument Parameters (boxing/unboxing)</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Version 1.2.0 (2019-11-02)</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0187; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-01 21:40:39Z; Modified: 2019-11-04 20:11:49Z.</emphasis>
        </superscript>
      </para>
      <para>Following changes</para>
      <itemizedlist>
        <listitem>
          <para>CREQ0162: String comparisons</para>
        </listitem>
        <listitem>
          <para>CREQ0175: Design patterns for testing</para>
        </listitem>
        <listitem>
          <para>CREQ0177: Debug and conditional checks</para>
        </listitem>
        <listitem>
          <para>CREQ0181: Common implementation, buffer range checks</para>
        </listitem>
        <listitem>
          <para>CREQ0182: Editor Config file</para>
        </listitem>
        <listitem>
          <para>CREQ0183: Sort usings</para>
        </listitem>
        <listitem>
          <para>CREQ0185: Don't use static usings.</para>
        </listitem>
        <listitem>
          <para>CREQ0190: Organizing test code</para>
        </listitem>
        <listitem>
          <para>CREQ0195-202: NUnit Asserts and Fluent style</para>
        </listitem>
        <listitem>
          <para>CREQ0203: Visual Studio Analyzers, codes and rationale</para>
        </listitem>
        <listitem>
          <para>CREQ0235: Overloads should be adjacent</para>
        </listitem>
        <listitem>
          <para>CREQ0293: New section on types</para>
        </listitem>
        <listitem>
          <para>CREQ0297: New section about classes</para>
        </listitem>
        <listitem>
          <para>CREQ0300: New section about properties</para>
        </listitem>
        <listitem>
          <para>CREQ0305: String interpolation</para>
        </listitem>
        <listitem>
          <para>CREQ0306: Rule Suppression</para>
        </listitem>
        <listitem>
          <para>CREQ0313: Synchronization Primitives</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Version 1.2.1 (2019-11-15)</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0318; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-06 19:14:53Z; Modified: 2019-11-15 20:17:55Z.</emphasis>
        </superscript>
      </para>
      <para>Following changes</para>
      <itemizedlist>
        <listitem>
          <para>CREQ0317: IDE0016, IDE0066, IDE1006 should be disabled</para>
        </listitem>
        <listitem>
          <para>CREQ0321: Null</para>
        </listitem>
        <listitem>
          <para>CREQ0324: Object Oriented Design</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Version 1.2.2 (2019-12-20)</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0328; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-12-09 07:32:54Z; Modified: 2019-12-20 14:46:44Z.</emphasis>
        </superscript>
      </para>
      <para>Following changes</para>
      <itemizedlist>
        <listitem>
          <para>CREQ0058: Renamed to blocking behaviour</para>
        </listitem>
        <listitem>
          <para>CREQ0327: Document using factories to easily convert o async</para>
        </listitem>
        <listitem>
          <para>CREQ0330: Async programming model</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Version 1.2.3 (2022-06-30)</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0335; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2022-05-07 10:38:49Z; Modified: 2022-06-29 21:37:51Z.</emphasis>
        </superscript>
      </para>
      <para>Following changes</para>
      <itemizedlist>
        <listitem>
          <para>CREQ0215: Allow P/Invoke for partial classes</para>
        </listitem>
        <listitem>
          <para>CREQ0336: Single character variables</para>
        </listitem>
        <listitem>
          <para>CREQ0337: Read Only Properties</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
</chapter>
<chapter>
  <title>Naming</title>
  <para>
    <superscript>
      <emphasis>Requirement: CREQ0005; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:05:22Z; Modified: 2015-11-10 21:05:24Z.</emphasis>
    </superscript>
  </para>
  <section>
    <title>Variable Naming</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0006; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-09 08:38:52Z; Modified: 2019-11-02 12:26:16Z.</emphasis>
      </superscript>
    </para>
    <para>The variable naming scheme was chosen during the initial development of the Automation framework based on the .NET framework reference sources. The .NET reference sources have changed since then, these guidelines maintain some rules for historical reasons, and some more modern rules.</para>
    <section>
      <title>Casing of Parameters and Stack Variables Naming</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0007; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-09 08:42:15Z; Modified: 2015-11-10 21:10:30Z.</emphasis>
        </superscript>
      </para>
      <para>Names of private variables (variables defined on the stack of a method, or naming of parameters in a method) shall follow camelCasing with the initial letter being lower case.</para>
    </section>
    <section>
      <title>Module Variables</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0008; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-09 08:53:42Z; Modified: 2015-11-09 08:53:44Z.</emphasis>
        </superscript>
      </para>
      <section>
        <title>Module Variable Casing Naming</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0009; Author: jcurl; Status: Approved; Version: 1.0; Created: 2015-11-09 08:54:54Z; Modified: 2017-07-10 16:34:52Z.</emphasis>
          </superscript>
        </para>
        <para>The module variable shall have a prefix, followed by the name in PascalCasing with a capital letter at the beginning.</para>
      </section>
      <section>
        <title>Module Global Prefix</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0010; Author: jcurl; Status: Approved; Version: 1.0; Created: 2015-11-09 08:40:37Z; Modified: 2019-11-02 15:44:38Z.</emphasis>
          </superscript>
        </para>
        <para>Module global names shall have the scope of private, and be prefixed with <emphasis role="bold">m_</emphasis></para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <screen>private string m_Name;</screen>
      </section>
      <section>
        <title>Module Static Prefix</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0011; Author: jcurl; Status: Approved; Version: 1.0; Created: 2015-11-09 08:41:03Z; Modified: 2022-05-07 10:34:25Z.</emphasis>
          </superscript>
        </para>
        <para>Module global static names shall have the scope of private, and be prefixed with <emphasis role="bold">s_</emphasis></para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <screen>private static object s_Lock = new object();</screen>
      </section>
      <section>
        <title>Module Constants Prefix</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0012; Author: jcurl; Status: Approved; Version: 1.0; Created: 2015-11-09 08:41:52Z; Modified: 2019-11-02 12:26:42Z.</emphasis>
          </superscript>
        </para>
        <para>Modules with <emphasis role="bold">public</emphasis>, <emphasis role="bold">protected</emphasis>, <emphasis role="bold">internal </emphasis>and <emphasis role="bold">private </emphasis>scope shall have no prefix.</para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <screen>private const string DefaultName = "Default";
public const int NoSizeLimit = 0;</screen>
      </section>
      <section>
        <title>Pseudo Constants (Private Static Readonly)</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0137; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Status: Proposed; Version: 1.0; Created: 2017-07-10 17:55:33Z; Modified: 2019-11-02 12:27:03Z.</emphasis>
          </superscript>
        </para>
        <para>In some cases, the intention of a variable is for it to be a constant (but cannot be due to runtime considerations). Variables marked as <emphasis role="bold">private static readonly Xx[] Value</emphasis> may be also considered as a constant.</para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <screen>private static readonly short[] Table = { ... };</screen>
      </section>
    </section>
    <section>
      <title>Variable Types in the Name</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0013; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-09 08:53:23Z; Modified: 2015-11-09 08:53:27Z.</emphasis>
        </superscript>
      </para>
      <section>
        <title>Type Name in the Class Type</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0014; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-09 08:55:47Z; Modified: 2016-07-25 20:32:52Z.</emphasis>
          </superscript>
        </para>
        <para>Naming of new classes should follow the naming guidelines of MSDN (TBD: Reference).</para>
        <para>Such examples are:</para>
        <itemizedlist>
          <listitem>
            <para>class MyStream : Stream</para>
          </listitem>
          <listitem>
            <para>class MyEventArgs : EventArgs</para>
          </listitem>
          <listitem>
            <para>class MyException : Exception</para>
          </listitem>
          <listitem>
            <para>class MyAttribute : Attribute</para>
          </listitem>
        </itemizedlist>
        <para>This is different to Hungarian notation where the type name is abbreviated and placed first.</para>
      </section>
      <section>
        <title>Hungarian Notation</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0015; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-09 08:43:07Z; Modified: 2015-11-09 08:53:31Z.</emphasis>
          </superscript>
        </para>
        <para>Hungarian notation shall not be used for any non-Windows forms code.</para>
      </section>
      <section>
        <title>Windows Forms Hungarian Notation</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0016; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-09 08:44:02Z; Modified: 2022-06-29 20:37:08Z.</emphasis>
          </superscript>
        </para>
        <para>A best practice from Visual Basic (since version 3!) is to use Hungarian notation for the identification of GUI objects. This makes it easy to identify the type of control being references, as well as to sort the controls.</para>
        <para>Objects in a Windows Forms project shall be prefixed with the object type (starting in lower case), followed by a more detailed description of the object.</para>
        <section>
          <title>Recommended Abbreviations for Windows Forms</title>
          <para>
            <superscript>
              <emphasis>Requirement: CREQ0017; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-09 08:45:14Z; Modified: 2022-06-29 20:37:33Z.</emphasis>
            </superscript>
          </para>
          <para>An example is given at: https://support.microsoft.com/en-us/kb/173738</para>
          <para>The following prefixes for Windows forms should be used:</para>
          <itemizedlist>
            <listitem>
              <para>btn - Button Control</para>
            </listitem>
          </itemizedlist>
          <itemizedlist>
            <listitem>
              <para>chk - Checkbox    </para>
            </listitem>
            <listitem>
              <para>cmb - Combobox    </para>
            </listitem>
            <listitem>
              <para>fra - Frame    </para>
            </listitem>
            <listitem>
              <para>frm - Form</para>
            </listitem>
            <listitem>
              <para>grp - Group Box</para>
            </listitem>
            <listitem>
              <para>img - Image list    </para>
            </listitem>
            <listitem>
              <para>lbl - Label     </para>
            </listitem>
            <listitem>
              <para>lbltxt - A Label control that usually prefixes a Text control in the tabbing order of the same name.     </para>
            </listitem>
            <listitem>
              <para>lst - List Control     </para>
            </listitem>
            <listitem>
              <para>lvw - List View    </para>
            </listitem>
            <listitem>
              <para>opt - Option Button</para>
            </listitem>
            <listitem>
              <para>pic - Picture Control</para>
            </listitem>
            <listitem>
              <para>prg - Progress Bar</para>
            </listitem>
            <listitem>
              <para>tab - Tab Control</para>
            </listitem>
            <listitem>
              <para>tvw - Tree View</para>
            </listitem>
            <listitem>
              <para>txt - Text Control</para>
            </listitem>
            <listitem>
              <para>mnu - Menu Item</para>
            </listitem>
          </itemizedlist>
          <para>Other prefixes are sometimes used in projects. The project should be at least consistent in the usage of the prefixes. For example:</para>
          <itemizedlist>
            <listitem>
              <para>but, cmd - Button</para>
            </listitem>
            <listitem>
              <para>cbo - Combo Box</para>
            </listitem>
            <listitem>
              <para>lstv - List View</para>
            </listitem>
            <listitem>
              <para>pro - Progress Bar</para>
            </listitem>
            <listitem>
              <para>rdo - Radio Button (option button)</para>
            </listitem>
            <listitem>
              <para>tre - Tree View</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>
    </section>
  </section>
  <section>
    <title>Name Abbreviations</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0018; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:19:32Z; Modified: 2015-11-16 21:06:31Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Abbreviations and Contractions</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0019; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-16 21:06:03Z; Modified: 2017-08-12 18:25:22Z.</emphasis>
        </superscript>
      </para>
      <para>Variable names should avoid abbreviations or contractions of identifiers where possible and be correctly spelled.</para>
      <para>
        <emphasis role="bold">GOOD</emphasis>: TraceServer</para>
      <para>
        <emphasis role="bold">BAD</emphasis>: TraceSvr</para>
      <para>
        <emphasis role="bold">GOOD</emphasis>: CommandLine</para>
      <para>
        <emphasis role="bold">BAD</emphasis>: CmdLine</para>
    </section>
    <section>
      <title>Commonly Used Abbreviations</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0020; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-16 21:06:59Z; Modified: 2017-08-12 18:25:31Z.</emphasis>
        </superscript>
      </para>
      <para>The usage of appropriate abbreviations should be used where they are common in the computing domain.</para>
      <para>
        <emphasis role="bold">Example</emphasis>: Dns, Xml, IP, IO, Gui, Http</para>
    </section>
    <section>
      <title>Casing of Abbreviations</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0021; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-16 21:08:06Z; Modified: 2019-11-04 19:54:47Z.</emphasis>
        </superscript>
      </para>
      <para>Common abbreviations that are two characters should be both upper case. Abbreviations of three characters or more should be capitalized, with the remaining characters being lower case.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <para>The namespace <emphasis role="bold">MyCompany.IO</emphasis> is preferred over <emphasis role="bold">MyCompany.Io</emphasis>.</para>
    </section>
    <section>
      <title>Common Limited Scoped Variables</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0336; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2022-06-29 20:38:02Z; Modified: 2022-06-29 21:15:21Z.</emphasis>
        </superscript>
      </para>
      <para>Simple variable names may be used where there use is limited in scope.</para>
      <para>
        <emphasis role="bold">Example</emphasis>: for (int i = 0; i &lt; 10; i++) { ... }</para>
      <para>
        <emphasis role="bold">Example</emphasis>: while (i &lt; 10) { char c = myVar[i]; i++ }</para>
      <para>
        <emphasis role="bold">Example</emphasis>: float f = 10.0;</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>Variables should be concise, accurate and reflect the domain in which they're used. Cartesian coordinates such as p = (x, y, z), or loop variables i, j, k (and similar single character names, as taken from Fortran 77) for example. The higher the cyclomatic complexity, the less suitable single character variables. And so this is dependent on the ideas being expressed in code.</para>
    </section>
  </section>
  <section>
    <title>Namespaces</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0022; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:02:22Z; Modified: 2015-11-10 21:05:53Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Namespace Elements</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0023; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-16 21:10:38Z; Modified: 2022-06-29 21:17:19Z.</emphasis>
        </superscript>
      </para>
      <para>The first element(s) of the namespace should represent the organization, followed by the technology, then further the feature and design.</para>
      <para>
        <emphasis role="bold">Example</emphasis>: </para>
      <itemizedlist>
        <listitem>
          <para>RJCP.Log.Dlt</para>
        </listitem>
        <listitem>
          <para>RJCP.Windows.Forms</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Unique Naming</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0024; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:06:30Z; Modified: 2017-12-26 14:49:51Z.</emphasis>
        </superscript>
      </para>
      <para>A class name should be different to any of the existing names in the namespace, or resolvable class names.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <screen>namespace NS1 {
  class CS1 { }
}</screen>
      <screen>namespace NS1.NS2 {
  // Not allowed
  class CS1 { }
}</screen>
      <screen>namespace NS1 {
  // Not allowed
  class NS2 { }
}</screen>
    </section>
  </section>
  <section>
    <title>Class Naming</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0025; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-16 21:12:40Z; Modified: 2015-11-16 21:12:44Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Name of the Class</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0026; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-16 21:12:45Z; Modified: 2015-11-16 21:13:47Z.</emphasis>
        </superscript>
      </para>
      <para>The name of the class should be a noun, or a noun phrase, following the general naming rules given above (PascalCasing, no underscores, etc.).</para>
    </section>
  </section>
  <section>
    <title>Interfaces</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0027; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-16 21:14:06Z; Modified: 2015-11-16 21:14:09Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Name of the Interface</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0028; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-16 21:14:11Z; Modified: 2015-11-16 21:14:53Z.</emphasis>
        </superscript>
      </para>
      <para>Interfaces should follow the same rules as the Class, but always begin with the capital letter 'I' (i).</para>
    </section>
  </section>
</chapter>
<chapter>
  <title>Code Formatting Style for C#</title>
  <para>
    <superscript>
      <emphasis>Requirement: CREQ0030; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-06-13 09:43:07Z; Modified: 2015-11-10 20:51:37Z.</emphasis>
    </superscript>
  </para>
  <para>The coding style attempts to provide as much information as possible on a single screen to help avoid errors associated with complexity.</para>
  <itemizedlist>
    <listitem>
      <para>Reduce the amount of whitespace on the screen, so that each method should ideally fit within a single screen. If a method is longer, then the cyclomatic complexity is likely too high.   </para>
    </listitem>
    <listitem>
      <para>Make it visually easier to identify where a method starts and then stops.   </para>
    </listitem>
  </itemizedlist>
  <section>
    <title>Visual Studio 2019 and the .editorconfig</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0182; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-01 21:29:10Z; Modified: 2019-11-01 21:30:13Z.</emphasis>
      </superscript>
    </para>
    <para>The project should define a file called <emphasis role="bold">.editorconfig</emphasis>, which is in the root folder. The configuration file should define the styles given in this coding standard.</para>
  </section>
  <section>
    <title>Colour Scheme in VS2017 and VS2019</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0329; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-12-15 20:39:53Z; Modified: 2019-12-15 20:40:43Z.</emphasis>
      </superscript>
    </para>
    <para>Do not use the High Contrast colour scheme in Visual Studio. It has been observed that "fade unused code blocks and using" does not work. Changing the colour scheme to a non-high contrast scheme works as expected.</para>
  </section>
  <section>
    <title>Usage of Braces for Control Statements</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0031; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-14 22:29:00Z; Modified: 2019-11-01 21:30:56Z.</emphasis>
      </superscript>
    </para>
    <para>Braces should be used for all control statements, even if that control statement has only one line.</para>
    <para>Exceptions to this rule might be for single line statements that either throw an exception or return immediately.</para>
    <para>No exceptions should be made on if-statements if there is an else or an else-if statement in use.</para>
    <para>
      <emphasis role="bold">Rationale</emphasis>: Often, in reviews and code changes, the lack of braces and incorrect formatting can lead to code appearing as though it is within a control block, where although in reality it is outside of the control block leading to unexpected behavior.</para>
    <para>The second is the "dangling else" case, where it is not clear to which control statement an else statement may belong.</para>
    <para>
      <emphasis role="bold">Example</emphasis>:</para>
    <screen>if (a)
  if (b)
    c;
else
  d;</screen>
    <para>is not distinguishable from</para>
    <screen>if (a)
  if (b)
    c;
  else
    d;</screen>
    <para>Although the two examples are identical, it's not clear to which if statement the 'else' belongs to. This should be made explicit with braces.</para>
  </section>
  <section>
    <title>Position of Braces for Control Statements</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0032; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-06-13 09:46:05Z; Modified: 2019-11-01 21:33:18Z.</emphasis>
      </superscript>
    </para>
    <para>The opening brace '{' shall be on the same line as the <emphasis role="bold">if</emphasis>, <emphasis role="bold">else if</emphasis>, <emphasis role="bold">else</emphasis>, switch delegates and other constructs which occur within a method.</para>
    <para>The closing brace '}' should begin on a new line (unless the complete statement and substatements fit completely on a single line). Following the closing brace on the same line should be chained statements, such as <emphasis role="bold">else</emphasis>, <emphasis role="bold">else if</emphasis>.</para>
    <para>
      <emphasis role="bold">Example</emphasis>:</para>
    <screen>if (a) {
  DoSomething();
} else if {
  SecondOption();
} else {
  DoSomethingElse();
}</screen>
  </section>
  <section>
    <title>Switch and Case Statements</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0033; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-06-13 09:48:53Z; Modified: 2019-11-01 21:34:11Z.</emphasis>
      </superscript>
    </para>
    <para>The case statements shall align to the left of the switch statement.</para>
    <para>This helps avoid the situation that code appears heavily nested.</para>
    <para>
      <emphasis role="bold">Example</emphasis>:</para>
    <screen>switch (value) {
case 1:
  Console.WriteLine("One");
  break;
case 2:
  Console.WriteLine("Two");
  break;
default:
  Console.WriteLine("Unknown");
  break;
}</screen>
  </section>
  <section>
    <title>Spaces for Indentation</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0034; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-06-13 09:49:56Z; Modified: 2017-08-12 18:26:10Z.</emphasis>
      </superscript>
    </para>
    <para>Spaces shall be used for indentation, with 4 spaces being equivalent to 1 tab.</para>
    <para>
      <emphasis role="bold">Rationale</emphasis>: A single tab is typically 8 spaces. This makes spacing excessive. One can configure an IDE to interpret a tab as 4 spaces but is tedious and manual work. By using spaces, it can be guaranteed consistent results regardless of the IDE (or diff tool) in use.</para>
    <para>Other projects might have used 2 or 3 spaces for tabs. Using 2 spaces provides insufficient indentation to identify problematic code due to heavily nested statements. 3 spaces is discarded as it's not aligned with any of the default tabbing.</para>
  </section>
  <section>
    <title>Commenting within the Code</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0035; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-14 22:33:55Z; Modified: 2017-08-12 18:26:13Z.</emphasis>
      </superscript>
    </para>
    <para>Comments within the code should be avoided, instead a preference to more descriptive naming of variables and method that describes the code in the same way.</para>
    <para>Similarly, MAML documentation of internal and private methods should only be provided if it brings value, with a preference instead for descriptive naming of the method and parameters of the method.</para>
    <para>
      <emphasis role="bold">Rationale</emphasis>: Providing documentation for simple methods increases workload and burden, allowing for a higher probability later of incorrect documentation should the code change (as it's often documentation is not updated when code is updated).</para>
  </section>
</chapter>
<chapter>
  <title>C# Language Specific Features</title>
  <para>
    <superscript>
      <emphasis>Requirement: CREQ0134; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Status: Proposed; Version: 1.0; Created: 2017-02-15 21:45:56Z; Modified: 2017-02-15 21:46:05Z.</emphasis>
    </superscript>
  </para>
  <section>
    <title>Using Statements</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0036; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-09 08:13:46Z; Modified: 2019-11-02 12:29:53Z.</emphasis>
      </superscript>
    </para>
    <para>The <emphasis role="bold">using</emphasis> statement has an effect if different when it is inside the namespace or outside the namespace.</para>
    <para>Having project references inside the namespace means that each <emphasis role="bold">using </emphasis>statement doesn't need to have the complete tree referenced. Having non-project references (e.g. the System namespace) inside the namespace implies that they take preference over the project namespaces.</para>
    <para>There is a tradeoff between the desire of just being able to update the project namespace, without having to update all references of the project namespace, and having the standard namespaces as first.</para>
    <para>Let's say we have the namespace <emphasis role="bold">MYPROJECT.Environment</emphasis> (there's also a <emphasis role="bold">System.Environment</emphasis>) and <emphasis role="bold">MYPROJECT.NewFeature</emphasis>.</para>
    <screen>namespace MYPROJECT.AnotherFeature {
  using System;
  using NewFeature;

  public class NextGenFeature {
    public void DoSomething() {
      // Equivalent: MYPROJECT.NewFeature.NewFeatureClass.StaticMethod()
      NewFeatureClass.StaticMethod();

      // Equivalent: System.Environment.Exit(0)
      Environment.Exit(0);
    }
  }
}</screen>
    <section>
      <title>Using System (and non-project references) Inside the Namespace</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0037; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-09 08:14:03Z; Modified: 2019-11-02 12:30:04Z.</emphasis>
        </superscript>
      </para>
      <para>The <emphasis role="bold">using </emphasis>statements of the <emphasis role="bold">System.*</emphasis> namespace should occur within the namespace. They should be first and sorted in alphabetical order.</para>
    </section>
    <section>
      <title>Using Project References Inside the Namespace</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0038; Author: jcurl; Stereotype: Functional; Status: Proposed; Version: 1.0; Created: 2015-11-09 08:14:56Z; Modified: 2022-06-29 21:40:47Z.</emphasis>
        </superscript>
      </para>
      <para>The <emphasis role="bold">using </emphasis>statements should occur within the namespace. They should occur last, be in alphabetical order. They should not reference the namespace in which they reside.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>: Some of the software used may be exported as Open Source (see https://github.com/jcurl/serialportstream). In this case, to ensure that the namespaces are separated to avoid any possible conflicts with open source, the root namespace is changed to suit that of the project (<emphasis role="bold">RJCP.IO.Ports</emphasis> renamed to <emphasis role="bold">NEWPROJ.IO.Ports</emphasis>). The number of internal reference changes is minimal.</para>
    </section>
    <section>
      <title>Sort Using</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0183; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-01 21:36:28Z; Modified: 2019-11-02 12:30:30Z.</emphasis>
        </superscript>
      </para>
      <para>There is an option in Visual Studio 2013 and later to ensure that <emphasis role="bold">System.*</emphasis> namespaces are sorted first:</para>
      <itemizedlist>
        <listitem>
          <para>Options -&gt; Text Editor -&gt; C# -&gt; Advanced</para>
        </listitem>
        <listitem>
          <para>Organize Usings -&gt; Place 'System' directives first when sorting usings</para>
        </listitem>
      </itemizedlist>
      <para>
        <emphasis role="bold">Rationale</emphasis>: Sorting in alphabetical order helps to quickly identify the using statements.</para>
    </section>
    <section>
      <title>Remove Unused Using</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0184; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-01 21:37:34Z; Modified: 2019-11-01 21:38:03Z.</emphasis>
        </superscript>
      </para>
      <para>Source files should have any <emphasis role="bold">using </emphasis>statement which is not referenced as being removed.</para>
    </section>
    <section>
      <title>Static Using</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0185; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-01 21:38:54Z; Modified: 2019-11-01 21:40:14Z.</emphasis>
        </superscript>
      </para>
      <para>Do not use the feature</para>
      <screen>using static Class;</screen>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>Many code reviews are done within WebEditors, such as Gerrit, BitBucket, GitHub, etc. Excessive usage of this feature may make it difficult more to know the source of the function being called, and can lead to a loss of quality during the code review.</para>
    </section>
  </section>
  <section>
    <title>Parameters</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0135; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Status: Proposed; Version: 1.0; Created: 2017-02-15 21:47:42Z; Modified: 2019-11-02 18:07:30Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Don't use Optional Parameters for Public API</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0136; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Status: Proposed; Version: 1.0; Created: 2017-02-15 21:47:50Z; Modified: 2022-06-29 21:19:48Z.</emphasis>
        </superscript>
      </para>
      <para>Optional parameters shall not be used for public API's.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <itemizedlist>
        <listitem>
          <para>Changing a method signature using optional parameters can cause existing clients to break. That leads to breaking backwards compatibility.</para>
        </listitem>
        <listitem>
          <para>When avoiding the backwards compatibility issue by adding a new overload, an ambiguity on determining the correct method may then result.</para>
        </listitem>
      </itemizedlist>
      <para>For more information, see the link: http://haacked.com/archive/2010/08/10/versioning-issues-with-optional-arguments.aspx/</para>
      <para>An exception to this rule would be to have similar API to what is provided in the .NET framework (e.g. streams in .NET Core 5).</para>
    </section>
    <section>
      <title>Named Parameters</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0149; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Status: Proposed; Version: 1.0; Created: 2017-12-26 14:42:08Z; Modified: 2019-11-02 18:07:56Z.</emphasis>
        </superscript>
      </para>
      <para>Avoid named parameters in function/constructor calls</para>
      <para>C# allows the use of named parameters when calling functions to improve readability. This is especially true for boolean inputs. However, there are other reasons against.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <itemizedlist>
        <listitem>
          <para>Using named parameters makes reviews in Web Browsers (such as Crucible, BitBucket, Gerrit) more difficult when trying to find the correct function being reviewed. MSDN lists each overload showing the type, not the parameter name. To find the documentation for a specific function using MSDN is easier without named parameters.</para>
        </listitem>
        <listitem>
          <para>If a parameter name changes, but not the signature, software will no longer compile.</para>
        </listitem>
      </itemizedlist>
      <para>An exception to this rule might be defining attributes in code for:</para>
      <itemizedlist>
        <listitem>
          <para>Code analysis warning/message suppression</para>
        </listitem>
        <listitem>
          <para>Test case attributes specifying the test name or other properties</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Prefer Return Values over ref and out</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0331; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-12-15 20:45:47Z; Modified: 2022-06-29 21:20:40Z.</emphasis>
        </superscript>
      </para>
      <para>Prefer the usage of returning values from a function than the usage of referenced parameters (those with the keyword <emphasis role="bold">ref </emphasis>and <emphasis role="bold">out</emphasis>).</para>
      <para>The usage of <emphasis role="bold">out </emphasis>is suitable for situations where users are used to similar situations with existing frameworks, e.g.</para>
      <screen>bool TryGetValue(string key, out object value)</screen>
      <para>
        <emphasis role="bold">Rationale</emphasis>: This promotes functional style programming which is easier to verify.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>: In newer versions of the language, you can return Tuples.</para>
    </section>
  </section>
  <section>
    <title>NameOf</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0148; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Status: Proposed; Version: 1.0; Created: 2017-12-26 14:39:46Z; Modified: 2019-11-02 18:08:01Z.</emphasis>
      </superscript>
    </para>
    <para>Using the <emphasis role="bold">nameof </emphasis>keyword (available in C# 5.0, VS2012 and later) avoids incorrect spelling of method and parameter names (errors thus resulting in compilation failures). IDEs also typically support refactoring of variable renaming resulting in automatic updates to the arguments of <emphasis role="bold">nameof</emphasis>, reducing effort.</para>
    <para>
      <emphasis role="bold">Rationale</emphasis>:</para>
    <para>Using the <emphasis role="bold">nameof </emphasis>keyword avoid incorrect spelling of names (that would otherwise result in compilation failures), and assists with renaming of variables.</para>
    <para>It can be used for exception parameter names, or in reflection for names of methods and properties (when using Invoke).</para>
  </section>
  <section>
    <title>Classes</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0297; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 15:11:31Z; Modified: 2019-11-02 15:11:34Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Partial Classes</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0215; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:07:47Z; Modified: 2022-06-29 21:21:40Z.</emphasis>
        </superscript>
      </para>
      <para>The use of <emphasis role="bold">partial </emphasis>classes should generally be avoided.</para>
      <para>Some instances where partial classes are useful:</para>
      <itemizedlist>
        <listitem>
          <para>Use with code generators, where a user might provide their implementation on top, while IDE helpers keep the generated code separated (such an example is WinForms).</para>
        </listitem>
        <listitem>
          <para>P/Invoke, where the top level class is used like a namespace (e.g. Kernel32) and it is expected to contain a lot of nested classes and structs.</para>
        </listitem>
      </itemizedlist>
      <para>Using it in the design for normal classes shows that the class is likely too large and should be refactored into smaller components.</para>
    </section>
    <section>
      <title>Nested Classes</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0216; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:09:12Z; Modified: 2019-11-02 15:11:38Z.</emphasis>
        </superscript>
      </para>
      <para>Related to <emphasis role="bold">partial </emphasis>classes, nested classes should be kept at a minimum.</para>
      <para>It is considered a problem when the usage of nested classes leads to source files so large that partial classes are considered. Consider using namespaces instead.</para>
      <para>One exception to this might be providing a suite of functions within a static class. The <emphasis role="bold">static </emphasis>class could be <emphasis role="bold">partial</emphasis>, while the functions themselves are considered in a single source file. However, even this case should be reconsidered if it should be instead that a single <emphasis role="bold">static </emphasis>class provides a wrapper for new <emphasis role="bold">internal static </emphasis>classes that are separated (and would therefore increase code readability).</para>
    </section>
    <section>
      <title>Calling the base</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0298; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 15:11:43Z; Modified: 2019-11-02 15:12:49Z.</emphasis>
        </superscript>
      </para>
      <para>Do not state the default constructor of the base class explicitly</para>
      <para>
        <emphasis role="bold">Old</emphasis>:</para>
      <screen>public class MyClass : BaseClass {
  public MyClass(string var) : base() { ... }
}</screen>
      <para>
        <emphasis role="bold">New</emphasis>
      </para>
      <screen>public class MyClass : BaseClass {
  public MyClass(string var) { ... }
}</screen>
    </section>
  </section>
  <section>
    <title>Types</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0293; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 15:00:42Z; Modified: 2019-11-02 15:09:37Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Use the Native Types</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0296; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 15:09:42Z; Modified: 2019-11-02 15:10:52Z.</emphasis>
        </superscript>
      </para>
      <para>Prefer the following types in C# over the System types</para>
      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">int </emphasis>over <emphasis role="bold">Int32</emphasis></para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">uint </emphasis>over <emphasis role="bold">UInt32</emphasis></para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">short </emphasis>over <emphasis role="bold">Int16</emphasis></para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">ushort </emphasis>over <emphasis role="bold">UInt16</emphasis></para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">byte </emphasis>over <emphasis role="bold">UInt8</emphasis></para>
        </listitem>
        <listitem>
          <para>
            <emphasis role="bold">sbyte </emphasis>of <emphasis role="bold">Int8</emphasis></para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Use TypeCasts instead of 'as'</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0294; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 15:00:51Z; Modified: 2022-06-29 21:23:01Z.</emphasis>
        </superscript>
      </para>
      <para>Where the type of an object is known at design time, type casts should be done directly.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <screen>IList list = new List();
List list2 = (List)list;</screen>
      <para>
        <emphasis role="bold">Rationale</emphasis>: Type casting directly is faster.</para>
    </section>
    <section>
      <title>Using the 'as' and 'is' operator</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0295; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 15:02:03Z; Modified: 2019-11-02 15:09:23Z.</emphasis>
        </superscript>
      </para>
      <para>Use the <emphasis role="bold">as </emphasis>operator for a safe typecast, which can be used later by checking against <emphasis role="bold">null </emphasis>if the object is that type or not.</para>
      <para>
        <emphasis role="bold">Good (older)</emphasis>:</para>
      <screen>public void (ICollection collection) {
  Queue queue = collection as Queue;
  if (queue != null) {
    ..
  }
}</screen>
      <para>
        <emphasis role="bold">Not recommended</emphasis>:</para>
      <para>is preferred over doing a cast twice</para>
      <screen>public void (ICollection collection) {
  if (collection is Queue) {
    Queue queue = (Queue)collection;
    ...
  }
}</screen>
      <para>and certainly not</para>
      <screen>public void (ICollection collection) {
  if (collection is Queue) {
    Queue queue = collection as Queue;
    ...
  }
}</screen>
      <para>use the <emphasis role="bold">is </emphasis>operator if only types need to be compared, but are not used.</para>
      <para>
        <emphasis role="bold">Good (New)</emphasis>:</para>
      <para>In newer versions of C# this should now be written as</para>
      <screen>public void (ICollection collection) {
  if (collection is Queue queue) {
    ...
  }
}</screen>
    </section>
  </section>
  <section>
    <title>Properties</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0300; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 15:18:39Z; Modified: 2019-11-02 15:20:02Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Use Auto Properties</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0302; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 15:20:37Z; Modified: 2019-11-02 15:21:51Z.</emphasis>
        </superscript>
      </para>
      <para>Auto properties should be used where ever possible. These look like a field, make code smaller and compact avoiding boiler plate code.</para>
    </section>
    <section>
      <title>Auto Property Assignment</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0303; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 15:21:56Z; Modified: 2022-06-29 21:23:58Z.</emphasis>
        </superscript>
      </para>
      <para>In Visual Studio 2017 and later, it is now possible to assign values to auto properties.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <screen>public int MyProperty { get; private set; } = 42;</screen>
      <para>By assigning auto properties like this, it no longer needs to be explicitly done in the constructor. The addition of new constructors is less error prone as such properties will be set and less likley to be forgotten.</para>
      <para>
        <emphasis role="bold">Old</emphasis>:</para>
      <screen>private int m_MyProperty = 42;
public int MyProperty {
  get { return m_MyProperty; }
  private set { m_MyProperty = value; }
}</screen>
    </section>
    <section>
      <title>Initialization of Properties that are Read Only</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0337; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2022-06-29 21:23:30Z; Modified: 2022-06-29 21:25:33Z.</emphasis>
        </superscript>
      </para>
      <para>In newer versions of .NET do not provide a private setter if that property is only set in the constructor.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <screen>public int MyProperty { get; } = 42;</screen>
      <para>
        <emphasis role="bold">Rationale</emphasis>: This is equivalent to readonly properties, and prevents code from setting the properties when they shouldn't.</para>
    </section>
  </section>
  <section>
    <title>Strings</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0304; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 18:08:22Z; Modified: 2019-11-02 18:08:23Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>String Interpolation (Production Code)</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0305; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 18:08:26Z; Modified: 2022-06-29 21:26:37Z.</emphasis>
        </superscript>
      </para>
      <para>Production code and code bases which should be maintained over a longer period of time should not use string interpolation.</para>
      <para>String interpolation can be used in projects where the language is expected to remain constant, for example, unit test projects and logging.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>String interpolation does not allow extracting the strings into resources for Internationalization. As projects grow and are used by more teams across the world internationalization is important.</para>
    </section>
  </section>
</chapter>
<chapter>
  <title>Design Patterns</title>
  <para>
    <superscript>
      <emphasis>Requirement: CREQ0039; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 20:52:04Z; Modified: 2015-11-10 20:52:11Z.</emphasis>
    </superscript>
  </para>
  <section>
    <title>Compatibility with .NET</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0040; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:16:13Z; Modified: 2015-11-17 08:16:17Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>CLSCompliant</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0041; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:18:34Z; Modified: 2019-11-02 12:13:00Z.</emphasis>
        </superscript>
      </para>
      <para>Assemblies should be marked as explicit <emphasis role="bold">CLSCompliant(true)</emphasis>, and methods should explicitly indicate that they are not <emphasis role="bold">CLSCompliant</emphasis>.</para>
    </section>
    <section>
      <title>Case Insensitivity</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0042; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:02:31Z; Modified: 2015-11-17 08:17:52Z.</emphasis>
        </superscript>
      </para>
      <para>Variables, methods, fields, types and name spaces shall differ by more than just their case. This allows support for other .NET languages and higher reuse (e.g. Visual Basic .NET is case insensitive, while C# is not).</para>
    </section>
  </section>
  <section>
    <title>Boxing and Unboxing</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0043; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:21:39Z; Modified: 2019-11-02 12:33:05Z.</emphasis>
      </superscript>
    </para>
    <para>Boxing is the process of taking a value type, allocating memory on the heap and copying the value to the new memory so that there is now a reference to it.</para>
    <para>There is the explicit instruction in IL called <emphasis role="bold">box</emphasis> that does this.</para>
    <section>
      <title>Using Generics to Avoid Boxing and Unboxing</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0044; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-16 20:18:31Z; Modified: 2015-11-17 08:16:09Z.</emphasis>
        </superscript>
      </para>
      <para>Datastructures should use Generics instead of the base object type, especially when value types can be used.</para>
      <para>The operation of copying a value type into the reference type object is expensive, involving a copy operation when converting from the value type to the reference type.</para>
    </section>
    <section>
      <title>Enum.HasFlag</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0159; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Stereotype: Functional; Status: Proposed; Version: 1.0; Created: 2018-06-01 23:07:39Z; Modified: 2019-11-02 12:33:19Z.</emphasis>
        </superscript>
      </para>
      <para>Avoid using the <emphasis role="bold">Enum.HasFlag</emphasis> in performance critical code. It will box twice, cause at least two memory allocations for each check. As an alternative, do bit comparisons.</para>
      <screen>myEnum.HasFlag(MyEnum.EnumValue);</screen>
      <para>results in boxing when converting the value type myEnum to a reference type, and then again converting MyEnum.EnumValue to a reference type:</para>
      <screen>// else if (((Enum)(object)myEnum).HasFlag((Enum)(object)MyEnum.EnumValue))
IL_0106: ldloc.0
IL_0107: box MyEnum
IL_010c: ldc.i4.2
IL_010d: box MyEnum
IL_0112: call instance bool [mscorlib]System.Enum::HasFlag(class [mscorlib]System.Enum)
// (no C# code)
IL_0117: brfalse.s IL_0126</screen>
      <para>As a reference, see https://stackoverflow.com/questions/7368652/what-is-it-that-makes-enum-hasflag-so-slow</para>
    </section>
    <section>
      <title>Argument Parameters</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0160; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Stereotype: Functional; Status: Proposed; Version: 1.0; Created: 2018-06-01 23:12:39Z; Modified: 2018-06-04 20:53:44Z.</emphasis>
        </superscript>
      </para>
      <para>Be careful with methods that have a signature such as:</para>
      <screen>Console.WriteLine(string format, params object[] arguments);</screen>
      <para>Using it such as:</para>
      <screen>Console.WriteLine("Values: {0} {1}", 1, 2);</screen>
      <para>will result in boxing the integer value types to reference types. There are two things that happen here:</para>
      <orderedlist>
        <listitem>
          <para>An array is automatically created by the compiler for arguments</para>
        </listitem>
        <listitem>
          <para>The value types are boxed into reference types and then stored into the array</para>
        </listitem>
      </orderedlist>
      <para>It is not at all efficient like C, where values are pushed onto the stack, but instead type safe and cannot cause stack corruption.</para>
    </section>
    <section>
      <title>Tracing</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0161; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Status: Proposed; Version: 1.0; Created: 2018-06-01 23:20:24Z; Modified: 2019-11-02 12:33:55Z.</emphasis>
        </superscript>
      </para>
      <para>A typical scenario where this occurs is tracing. Executing a trace, even if tracing is disabled, will result in a performance impact:</para>
      <screen>int bytesRead = stream.Read(buffer, 0, buffer.Length);
TraceSource.TraceEvent(TraceEventType.Information, 0,
  "{0}: Logged {1} bytes", m_Name, bytesRead);</screen>
      <para>This will also result in a new array being created, and the value type <emphasis role="bold">bytesRead </emphasis>being boxed into the array. Even if the user doesn't enable tracing, this will still occur.</para>
      <para>If a lot of tracing occurs (which typically does at verbose level) one should check to see if tracing is enabled first.</para>
      <para>MSDN suggests to not use <emphasis role="bold">TraceSource.ShouldTrace</emphasis>, however no other reasonable viable alternative is found.</para>
      <para>This will speed up your code in hot paths and reduce the number of allocations required on the heap.</para>
    </section>
  </section>
  <section>
    <title>Properties</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0045; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:19:19Z; Modified: 2015-11-17 08:19:22Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Exceptions in Get Properties</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0046; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-16 21:29:46Z; Modified: 2019-11-02 12:34:30Z.</emphasis>
        </superscript>
      </para>
      <para>Do not raise exceptions in the get field of a property. Instead return a default value.</para>
      <para>The only exception to this are exceptions of type <emphasis role="bold">InvalidOperationException </emphasis>and derived types (e.g. also <emphasis role="bold">ObjectDisposedException</emphasis>).</para>
    </section>
    <section>
      <title>Property State</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0047; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:19:35Z; Modified: 2019-11-02 12:34:54Z.</emphasis>
        </superscript>
      </para>
      <para>Properties should be allowed to be set in any order, and should be stateless with respect to other properties.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>A property looks like a variable to the programmer, and they expect it to behave like a variable. Only when a specific method is called, would the class enter a particular state that then uses these variables. Until then, the state of the properties shouldn't matter.</para>
    </section>
    <section>
      <title>Property Changed Events</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0048; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:22:09Z; Modified: 2019-11-02 12:35:04Z.</emphasis>
        </superscript>
      </para>
      <para>In the case that properties change, raise an event that ends in the name <emphasis role="bold">Changed</emphasis>.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <screen>public event EventHandler TextChanged;</screen>
    </section>
    <section>
      <title>Boolean State Properties</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0049; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:23:17Z; Modified: 2019-11-02 12:35:34Z.</emphasis>
        </superscript>
      </para>
      <para>Consider naming read-only properties that describe state or testing a feature by prefixing the property with <emphasis role="bold">Is</emphasis> or <emphasis role="bold">Has</emphasis>.</para>
      <para>Example:</para>
      <itemizedlist>
        <listitem>
          <para>IsConnected</para>
        </listitem>
        <listitem>
          <para>HasFeature</para>
        </listitem>
      </itemizedlist>
      <para>The read/write property if something is enabled or not would be <emphasis role="bold">Enabled</emphasis> and not <emphasis role="bold">IsEnabled</emphasis> as it's also writable.</para>
    </section>
    <section>
      <title>Read Only and Write Only Properties</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0050; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:25:25Z; Modified: 2019-11-02 12:36:02Z.</emphasis>
        </superscript>
      </para>
      <para>Properties may be read only. When writing them, they could raise an exception indicating that it is read only. The appropriate exception is <emphasis role="bold">InvalidOperationException</emphasis>.</para>
      <para>Properties should not be write-only. Replace such properties as methods.</para>
    </section>
    <section>
      <title>Don't Expose Public Fields</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0301; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 15:19:49Z; Modified: 2019-11-04 19:51:11Z.</emphasis>
        </superscript>
      </para>
      <para>Never expose fields as public.</para>
      <para>By using properties, implementations can extend to include performance optimizations (e.g. lazy initialization) and throw exceptions on invalid input. Often properties are exposed as read only, and shouldn't be set, which can't be done with fields.</para>
      <para>Converting from a public field to a property is a breaking change, requiring recompilation from all dependent projects.</para>
    </section>
  </section>
  <section>
    <title>Methods</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0051; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:27:09Z; Modified: 2015-11-17 08:27:10Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Overloading</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0052; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:27:11Z; Modified: 2019-11-02 12:37:37Z.</emphasis>
        </superscript>
      </para>
      <para>Overloading is having two methods of the same name with different signatures.</para>
      <para>All overloaded methods in the class should return the same type (or be <emphasis role="bold">void</emphasis>). IL does allow overloaded methods to return different types, this should be avoided for compatibility.</para>
      <para>Overloaded methods should be semantically the same.</para>
    </section>
    <section>
      <title>Overloading instead of Default Arguments</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0053; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:29:18Z; Modified: 2015-11-17 08:30:07Z.</emphasis>
        </superscript>
      </para>
      <para>Use overloading instead of defining default variables in the parameter list. Default arguments do not version well and therefore are not allowed in the Common Language Specification (CLS).</para>
    </section>
    <section>
      <title>Overloading Specific Types</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0054; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:32:58Z; Modified: 2019-11-02 12:37:57Z.</emphasis>
        </superscript>
      </para>
      <para>When operating on different types in the methods, it makes sense to overload. The .NET runtime will always resolve the method that is the most specific type. </para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <screen>WriteLine(MyStream stream);
WriteLine(Stream stream);</screen>
      <para>If <emphasis role="bold">WriteLine()</emphasis> is called with a type of <emphasis role="bold">MyStream </emphasis>(or derived types), it will call the first example. If called with <emphasis role="bold">MemoryStream </emphasis>(derived from <emphasis role="bold">Stream</emphasis>, but not <emphasis role="bold">MyStream</emphasis>), it will call the second instance.</para>
      <para>This makes code more readable/understandable.</para>
    </section>
    <section>
      <title>Overloaded methods should be adjacent</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0235; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:36:26Z; Modified: 2019-11-02 12:37:00Z.</emphasis>
        </superscript>
      </para>
      <para>When providing overloaded methods, try and keep all overloaded methods adjacent to one another. This allows for code to be found quicker.</para>
    </section>
    <section>
      <title>Ordering of Parameters of Overloaded Methods</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0236; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:38:05Z; Modified: 2019-11-02 12:42:26Z.</emphasis>
        </superscript>
      </para>
      <para>When having a method with multiple overloaded implementations, design the ordering of the API to extend previous methods.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>The Visual Studio IDE presents the user with information about the API, using the smallest number of parameters that match the current line. The user can use the up/down arrow keys to search through the APIs found to suit.</para>
      <para>If the following overloads are defined</para>
      <screen>int MyMethod();
int MyMethod(string message);
int MyMethod(string format, object params args[]);</screen>
      <para>the user can type and it will automatically show them the third method.</para>
      <para>But if the overloads were to be:</para>
      <screen>int MyMethod();
int MyMethod(string message);
int MyMethod(int count, string message);</screen>
      <para>the user would start with a string, and they would not be prompted with the count. Changing the last method to the signature below allows the IDE to present to the user the APIs the user is most likely searching for</para>
      <screen>int MyMethod(string message, int count);</screen>
    </section>
    <section>
      <title>Variable Number of Arguments</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0055; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:31:21Z; Modified: 2017-08-17 21:13:30Z.</emphasis>
        </superscript>
      </para>
      <para>Choose variable arguments in the signature for methods that are expected to take an unbounded number of elements.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <screen>SprintF(char format, params object[] args) { ... }</screen>
    </section>
  </section>
  <section>
    <title>Strings</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0162; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-06-20 13:21:35Z; Modified: 2019-06-20 13:21:38Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>String Comparisons</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0163; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-06-20 13:21:43Z; Modified: 2019-06-20 13:22:16Z.</emphasis>
        </superscript>
      </para>
      <para>Information for this section is derived from Microsoft's Best Practices for strings, found at https://docs.microsoft.com/en-us/dotnet/standard/base-types/best-practices-strings</para>
      <section>
        <title>Default String Operations</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0172; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-06-20 13:30:06Z; Modified: 2019-11-02 11:37:27Z.</emphasis>
          </superscript>
        </para>
        <para>Use overloads that explicitly specify the string comparison rules for string operations. Typically, this involves calling a method overload that has a parameter of type <emphasis role="bold">StringComparison</emphasis>.</para>
      </section>
      <section>
        <title>Sorting vs Equality</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0167; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-06-20 13:25:38Z; Modified: 2019-11-02 11:37:43Z.</emphasis>
          </superscript>
        </para>
        <para>Use the <emphasis role="bold">String.Compare</emphasis> and <emphasis role="bold">String.CompareTo</emphasis> methods to sort strings, not to check for equality.</para>
        <para>Use an overload of the <emphasis role="bold">String.Equals</emphasis> method to test whether two strings are equal.</para>
        <para>Do not use an overload of the <emphasis role="bold">String.Compare</emphasis> or <emphasis role="bold">CompareTo </emphasis>method and test for a return value of zero to determine whether two strings are equal.</para>
      </section>
      <section>
        <title>Linquistic Irrelevant Output should use StringComparison.Ordinal[IgnoreCase]</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0165; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-06-20 13:23:16Z; Modified: 2019-11-02 11:38:01Z.</emphasis>
          </superscript>
        </para>
        <para>Use the non-linguistic <emphasis role="bold">StringComparison.Ordinal</emphasis> or <emphasis role="bold">StringComparison.OrdinalIgnoreCase</emphasis> values instead of string operations based on <emphasis role="bold">CultureInfo.InvariantCulture</emphasis> when the comparison is linguistically irrelevant (symbolic, for example).</para>
        <para>Use <emphasis role="bold">StringComparison.Ordinal</emphasis> or <emphasis role="bold">StringComparison.OrdinalIgnoreCase</emphasis> for comparisons as your safe default for culture-agnostic string matching.</para>
      </section>
      <section>
        <title>User Output should use StringComparison.CurrentCulture</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0164; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-06-20 13:22:19Z; Modified: 2019-11-02 11:38:04Z.</emphasis>
          </superscript>
        </para>
        <para>Use string operations that are based on <emphasis role="bold">StringComparison.CurrentCulture</emphasis> when you display output to the user.</para>
      </section>
      <section>
        <title>User Output should use Culture-Sensitive formatting</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0169; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-06-20 13:27:46Z; Modified: 2019-06-20 13:28:03Z.</emphasis>
          </superscript>
        </para>
        <para>Use culture-sensitive formatting to display non-string data, such as numbers and dates, in a user interface. Use formatting with the invariant culture to persist non-string data in string form.</para>
      </section>
      <section>
        <title>Persistent Data should use InvariantCulture</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0171; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-06-20 13:29:41Z; Modified: 2019-06-20 13:31:40Z.</emphasis>
          </superscript>
        </para>
        <para>Do not use culture-sensitive formatting to persist numeric data or date and time data in string form.</para>
        <para>Comparison and casing behavior in .NET changes when the culture changes. This happens when an application executes on a computer that has a different culture than the computer on which the application was developed, or when the executing thread changes its culture.</para>
      </section>
      <section>
        <title>Normalized Comparison should use String.ToUpperVariant</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0166; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-06-20 13:24:59Z; Modified: 2019-11-02 11:38:11Z.</emphasis>
          </superscript>
        </para>
        <para>Use the <emphasis role="bold">String.ToUpperInvariant</emphasis> method instead of the <emphasis role="bold">String.ToLowerInvariant</emphasis> method when you normalize strings for comparison.</para>
      </section>
      <section>
        <title>Avoid StringComparison.InvariantCulture</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0170; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-06-20 13:28:39Z; Modified: 2019-11-02 11:38:15Z.</emphasis>
          </superscript>
        </para>
        <para>Do not use string operations based on <emphasis role="bold">StringComparison.InvariantCulture</emphasis> in most cases. One of the few exceptions is when you are persisting linguistically meaningful but culturally agnostic data.</para>
      </section>
      <section>
        <title>Performance</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0168; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-06-20 13:26:40Z; Modified: 2019-11-02 11:38:20Z.</emphasis>
          </superscript>
        </para>
        <para>Use comparisons with <emphasis role="bold">StringComparison.Ordinal</emphasis> or <emphasis role="bold">StringComparison.OrdinalIgnoreCase</emphasis> for better performance.</para>
        <para>But this should only be used in according to the other functional rules given in this section.</para>
      </section>
    </section>
    <section>
      <title>Generic Collections</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0173; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-06-20 19:13:31Z; Modified: 2019-06-20 19:13:36Z.</emphasis>
        </superscript>
      </para>
      <section>
        <title>Overload MyCollection&lt;T&gt; Comparison methods with IEqualityComparer&lt;T&gt;</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0174; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-06-20 19:13:41Z; Modified: 2019-11-02 12:43:13Z.</emphasis>
          </superscript>
        </para>
        <para>If the generic type <emphasis role="bold">T</emphasis> could possibly be a string, then it is mandatory to provide an overload of a comparison method with the parameter</para>
        <screen>IEqualityComparer&lt;T&gt; comparer</screen>
        <para>
          <emphasis role="bold">Rationale</emphasis>:</para>
        <para>You have a collection and it contains a method called ContainsValue.</para>
        <screen>public class MyCollection&lt;T&gt; {
  public bool ContainsValue(T item) {
    foreach (var entry in m_Items) {
      if (m_Items.Equals(item) return true;
    }
    return false;
  }</screen>
        <screen>  public bool ContainsValue(T item, IEqualityComparer&lt;T&gt; comparer) {
    foreach (var entry in m_Items) {
      if (comparer.Equals(item, entry)) return true;
    }
  }
}</screen>
        <para>This allows the method to be called as such:</para>
        <para>MyCollection&lt;string&gt; collection = new MyCollection&lt;string&gt;();</para>
        <para>collection.ContainsValue(item, StringComparer.Ordinal);</para>
        <para>Such an overload is mandatory when following the section on "String Comparisons".</para>
      </section>
    </section>
  </section>
  <section>
    <title>Constructors</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0056; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:36:32Z; Modified: 2017-12-26 16:00:22Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>No Blocking Behavior</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0058; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:43:14Z; Modified: 2019-12-09 07:30:28Z.</emphasis>
        </superscript>
      </para>
      <para>The constructor of a class should do as little work as possible, generally only initializing the object. Doing more can be CPU expensive for the application.</para>
      <para>Do NOT:</para>
      <itemizedlist>
        <listitem>
          <para>perform CPU intensive operations in the constructor</para>
        </listitem>
        <listitem>
          <para>load files in the constructor</para>
        </listitem>
      </itemizedlist>
      <para>Do:</para>
      <itemizedlist>
        <listitem>
          <para>Initialize variables only</para>
        </listitem>
      </itemizedlist>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>Initializing a class should not block, so as to not block GUI operations or cause unexpected delays in application code. It is not possible to implement asynchronous constructors.</para>
      <section>
        <title>Use the Factory Pattern</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0327; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-12-09 07:26:16Z; Modified: 2019-12-09 07:31:43Z.</emphasis>
          </superscript>
        </para>
        <para>A factory can be used to create an object and then to immediately use a method of that object to perform a long running operation if required. A factory method can be easily refactored to be an asynchronous method if required, returning a <emphasis role="bold">Task </emphasis>instead.</para>
      </section>
    </section>
    <section>
      <title>Static Only Classes</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0057; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:36:36Z; Modified: 2019-11-02 12:43:20Z.</emphasis>
        </superscript>
      </para>
      <para>Classes should be marked as <emphasis role="bold">static </emphasis>if it only contains <emphasis role="bold">static </emphasis>methods and properties. This marks the class as non-instantiable.</para>
      <para>If this is not possible, then a class should have a private default constructor defined that marks it as non-instantiable.</para>
    </section>
    <section>
      <title>Structs Empty Constructor</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0059; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:44:27Z; Modified: 2019-11-02 11:38:47Z.</emphasis>
        </superscript>
      </para>
      <para>Avoid defining an empty constructor for <emphasis role="bold">struct</emphasis>s. When a <emphasis role="bold">struct </emphasis>is defined on the heap, it is initialized with default values (e.g. zero), making initialization of the <emphasis role="bold">struct </emphasis>faster.</para>
    </section>
    <section>
      <title>Structs Constructor for Initialisation</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0060; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:45:30Z; Modified: 2019-11-02 11:38:52Z.</emphasis>
        </superscript>
      </para>
      <para>Having a constructor for a <emphasis role="bold">struct </emphasis>should only be a shortcut for setting the properties in the <emphasis role="bold">struct</emphasis>.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <screen>struct foo = new Foo("a", "b");</screen>
      <para>should be equivalent to:</para>
      <screen>struct foo = new Foo();
foo.a = "a";
foo.b = "b";</screen>
    </section>
    <section>
      <title>Copying and Side Effects</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0151; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Status: Proposed; Version: 1.0; Created: 2017-12-26 15:56:49Z; Modified: 2017-12-26 16:00:25Z.</emphasis>
        </superscript>
      </para>
      <para>When accepting an object as an input to a constructor, perform a deep copy.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>Making a deep copy prevents side effects if the input object were to be inadvertently changed later.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <para>A constructor takes a list of objects as an input. That list should be copied into a new list private to the new object. If not, there are now two references to the list, and modifying the original list will modify the state of the new object.</para>
      <screen>public ctor(IEnumerable input) {
  m_List = new List(input);
}</screen>
    </section>
    <section>
      <title>Organizing Class Constructors with Default Parameters</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0299; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 15:12:55Z; Modified: 2019-11-02 18:05:02Z.</emphasis>
        </superscript>
      </para>
      <para>When providing <emphasis>convenience</emphasis> constructors where parameters are not specified as they have default implementations, implement the constructor with the most parameters as the constructor with the implementation.</para>
      <para>One shouldn't define parameters with default values. Instead provide overloads. The overloads for the simplest case should just call the overload for the most complex case with the default value explicitly provided.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <screen>public class MyClass {
  public MyClass() : this(null, -1) { }
  public MyClass(string var) : this (var, -1) { }
  public MyClass(string var, int count) {
    // implementation
  }
}</screen>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <screen>public class MyClass {
  public MyClass() {
    Initialize(null, -1);
  }
  public MyClass(string var) {
    if (var == null) throw new ArgumentNullException(nameof(var);
    Initialize(var, -1);
  }
  public MyClass(string var, int count) {
    if (var == null) throw new ArgumentNullException(var);
    if (count &lt; 0) throw new ArgumentOutOfRangeException();
    Initialize(var, count)
  }

   private Initialize(string var, int count) { ... }
}</screen>
    </section>
  </section>
  <section>
    <title>Dispose Pattern (IDispose)</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0061; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 20:52:18Z; Modified: 2019-11-02 12:43:51Z.</emphasis>
      </superscript>
    </para>
    <para>Software shall take extra care in implementation of the <emphasis role="bold">Dispose </emphasis>pattern, as recommended by Microsoft.</para>
    <section>
      <title>Sealed Classes</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0062; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 20:52:50Z; Modified: 2019-11-15 07:08:02Z.</emphasis>
        </superscript>
      </para>
      <para>Classes that are <emphasis role="bold">sealed </emphasis>must implement <emphasis role="bold">Dispose </emphasis>without the <emphasis role="bold">protected </emphasis>method. If there are no unmanaged resources, the <emphasis role="bold">Dispose </emphasis>method does not need to call <emphasis role="bold">GC.SuppressFinalize(this)</emphasis>.</para>
    </section>
    <section>
      <title>Virtual Classes</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0063; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 20:53:10Z; Modified: 2019-11-15 07:07:57Z.</emphasis>
        </superscript>
      </para>
      <para>Classes that are inheritable, shall implement the <emphasis role="bold">public </emphasis><emphasis role="bold">Dispose</emphasis> method, along with the <emphasis role="bold">protected </emphasis><emphasis role="bold">Dispose</emphasis> method.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <screen>public Dispose() {
  Dispose(true);
  GC.SuppressFinalize(this);
}

protected Dispose(bool disposing) {
  if (disposing) {
    // Dispose .NET methods
  }
  // Free unmanaged resources
}</screen>
    </section>
    <section>
      <title>Unmanaged Resources</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0064; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 20:54:48Z; Modified: 2015-11-10 21:23:57Z.</emphasis>
        </superscript>
      </para>
      <section>
        <title>Separation of Managed and Unmanaged Resources</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0065; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:23:30Z; Modified: 2019-11-02 12:44:42Z.</emphasis>
          </superscript>
        </para>
        <para>A class should not have both managed and unmanaged objects in the <emphasis role="bold">Dispose </emphasis>pattern. Classes should be created explicitly to handle unmanaged resources, and only unmanaged resources.</para>
        <para>A class that then has managed and unmanaged resources simultaneously should be rewritten to handle only managed resources, where those managed resources might have the responsibility of handling the unmanaged resource alone.</para>
      </section>
      <section>
        <title>Sealed Classes</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0066; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:24:23Z; Modified: 2019-11-02 12:44:53Z.</emphasis>
          </superscript>
        </para>
        <para>An class managing unmanaged resources should generally be <emphasis role="bold">sealed</emphasis>, so it can't be inherited from.</para>
      </section>
      <section>
        <title>Finalizer</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0067; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:22:12Z; Modified: 2019-11-02 12:45:13Z.</emphasis>
          </superscript>
        </para>
        <para>A class shall only implement a finalizer when it has unmanaged resources. Otherwise, no finalizer shall be implemented to optimize the performance of the Garbage Collector.</para>
        <para>Combine this with the class being <emphasis role="bold">sealed</emphasis>, the time required for Garbage Collection is minimized.</para>
        <para>
          <emphasis role="bold">Rationale</emphasis>:</para>
        <para>Say that there are two classes, B2 and D2.</para>
        <screen>class B2 : IDisposable {
  public B2() { ... }
  public void Dispose() { ... }
  protected virtual void Dispose(bool disposing) { ... }
  public ~B2() { ... }
}

class D2 : B2 {
  public D2() { ... }
  public void Dispose() { ... }
  protected virtual void Dispose(bool disposing) { ... }
  public ~D2() { ... }
}</screen>
        <para>When the GC calls D2.Finalize (the destructor), the following methods are called:</para>
        <itemizedlist>
          <listitem>
            <para>D2.Finalize</para>
          </listitem>
          <listitem>
            <para>D2.Dispose(False)</para>
          </listitem>
          <listitem>
            <para>B2.Dispose(False)</para>
          </listitem>
          <listitem>
            <para>B2.Finalize</para>
          </listitem>
          <listitem>
            <para>D2.Dispose(False)</para>
          </listitem>
          <listitem>
            <para>B2.Dispose(False)</para>
          </listitem>
        </itemizedlist>
        <para>You can see that if the D2 finalizer is called, this results in the dispose method for the inheritance tree being called twice.</para>
      </section>
    </section>
  </section>
  <section>
    <title>Using 'null'</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0321; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-15 07:08:24Z; Modified: 2019-11-15 07:08:29Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Nullable Types</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0322; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-15 07:08:43Z; Modified: 2019-11-15 07:10:59Z.</emphasis>
        </superscript>
      </para>
      <para>Avoid whereever possible the use of nullable value types, like <emphasis role="bold">int?</emphasis>. </para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>It has been discussed that the null value is probably the biggest programming mistake made in history. Making a value type now a reference type that can be null increases the complexity of software and adds a new failure mode.</para>
    </section>
    <section>
      <title>Null Inputs and Null Properties</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0323; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-15 07:11:05Z; Modified: 2019-11-15 07:16:51Z.</emphasis>
        </superscript>
      </para>
      <para>Whereever possible, prevent inputs from being <emphasis role="bold">null</emphasis>. Prevent properties on your class from being <emphasis role="bold">null</emphasis>.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>Whenever a property can be <emphasis role="bold">null</emphasis>, it must be checked prior in user code for all instances of null. It is a common user mistake to not check for <emphasis role="bold">null</emphasis>, even if C# has introduced null coalescing operators, and the "Elvis" operator.</para>
      <para>If a property can never be <emphasis role="bold">null </emphasis>by design, this is one less <emphasis role="bold">NullReferenceException </emphasis>that can occur. Instead, return <emphasis role="bold">String.Empty</emphasis> for strings, provide default values for other reference types where possible.</para>
      <para>One design pattern in code is to receive inputs in the constructor of a class and then to set properties of the class appropriately. Don't allow those inputs to be <emphasis role="bold">null</emphasis>, and thus the properties also won't be <emphasis role="bold">null</emphasis>, and there is less code overall that has to check for <emphasis role="bold">null</emphasis>, making code simpler to read and potentially faster by removing unnecessary checks.</para>
    </section>
  </section>
  <section>
    <title>Singletons</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0068; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:40:34Z; Modified: 2015-11-17 08:40:36Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Usage</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0069; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:40:46Z; Modified: 2015-11-17 08:42:51Z.</emphasis>
        </superscript>
      </para>
      <para>Singletons should be generally avoided, or they are used sparingly.</para>
      <para>A singleton generally only makes sense if that class should, by design, only be instantiated once in the entire application. Framework / reusable components generally don't need singleton classes.</para>
      <para>A singleton makes sense for application specific classes, such as holding application state or configuration (as for example, the main design pattern of WPF). This saves the object having to be passed in various places in the application model layer.</para>
    </section>
    <section>
      <title>Implementing a Singleton</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0129; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Status: Proposed; Version: 1.0; Created: 2017-02-15 21:22:35Z; Modified: 2019-11-02 12:45:36Z.</emphasis>
        </superscript>
      </para>
      <para>If a singleton should be required, one of the following design patterns should be used. <emphasis role="underline">http://csharpindepth.com/Articles/General/Singleton.aspx</emphasis></para>
      <para>Be careful of the usage of keywords such as <emphasis role="bold">volatile</emphasis>, <emphasis role="bold">readonly </emphasis>as given in the specific example. There may be the possibility of implementing subtle race conditions if used incorrectly.</para>
      <para>PROs of the static constructor implementation:</para>
      <orderedlist>
        <listitem>
          <para>Less code than double-check locking =&gt; less error-prone (the shorter the code, the fewer the bugs J).</para>
        </listitem>
        <listitem>
          <para>It is thread-safe without making use of locking mechanisms + allows CLR optimizations =&gt; from a performance perspective, it is more efficient.</para>
        </listitem>
      </orderedlist>
    </section>
  </section>
  <section>
    <title>Common Implementations</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0180; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-07-06 21:12:33Z; Modified: 2019-07-06 21:12:43Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Buffers and Range Checking</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0181; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-07-06 21:12:46Z; Modified: 2019-11-02 12:46:04Z.</emphasis>
        </superscript>
      </para>
      <para>Many methods take as an input an <emphasis role="bold">array</emphasis>, an <emphasis role="bold">offset </emphasis>and a <emphasis role="bold">length</emphasis>.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <screen>public void CopyTo(T[] array, int offset, int length)
public int Read(byte[] buffer, int offset, int length)
public void Write(byte[] buffer, int offset, int length)</screen>
      <para>The following checks should be standard, to be similar to .NET implementation and that user know how to handle the exceptions.</para>
      <para>
        <emphasis role="bold">ArgumentNullException</emphasis>: Returned if the array/buffer is <emphasis role="bold">null</emphasis>. The parameter name is the argument.</para>
      <para>
        <emphasis role="bold">ArgumentOutOfRangeException</emphasis>: Returned if the <emphasis role="bold">offset</emphasis>, or <emphasis role="bold">length</emphasis>, are less than zero. The parameter name is the argument.</para>
      <para>
        <emphasis role="bold">ArgumentException</emphasis>: If the <emphasis role="bold">offset </emphasis>and <emphasis role="bold">length </emphasis>would exceed the boundaries of the <emphasis role="bold">array</emphasis>. The check should be using differences, rather than summation, to avoid potential overflow issues. There is no parameter name.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <screen>if (buffer == null)
  throw new ArgumentNullException(nameof(buffer));
if (offset &lt; 0)
  throw new ArgumentOutOfRangeException(nameof(offset), "may not be negative");
if (length &lt; 0)
  throw new ArgumentOutOfRangeException(nameof(length), "may not be negative");
if (offset &gt; buffer.Length - length)
  throw new ArgumentException("The length and offset would exceed the boundaries of the array/buffer");</screen>
    </section>
  </section>
  <section>
    <title>Critical Sections</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0130; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Status: Proposed; Version: 1.0; Created: 2017-02-15 21:23:40Z; Modified: 2017-02-15 21:23:52Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Use Locks instead of Monitor</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0131; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Status: Proposed; Version: 1.0; Created: 2017-02-15 21:23:54Z; Modified: 2019-11-02 12:46:21Z.</emphasis>
        </superscript>
      </para>
      <para>Where possible, the C# construct <emphasis role="bold">lock(object) { }</emphasis> should be used instead of the explicit implementation <emphasis role="bold">Monitor.Enter</emphasis> and <emphasis role="bold">Monitor.Exit</emphasis>.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>The compiler knows the precise scope of the <emphasis role="bold">lock </emphasis>and ensures that the <emphasis role="bold">lock </emphasis>is always freed properly. The <emphasis role="bold">lock </emphasis>construct also ensures that a critical section's scope remains completely within a single function.</para>
    </section>
    <section>
      <title>Define an Object for a Lock</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0132; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Status: Proposed; Version: 1.0; Created: 2017-02-15 21:25:59Z; Modified: 2019-11-02 12:46:58Z.</emphasis>
        </superscript>
      </para>
      <para>Generally, locks should be made on dedicated <emphasis role="bold">lock object</emphasis>s instead of data types.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <itemizedlist>
        <listitem>
          <para>A <emphasis role="bold">lock object</emphasis> can be named to make clear the condition it protects. Generally a <emphasis role="bold">lock </emphasis>is named after a verb on an <emphasis role="bold">object</emphasis>, e.g. <emphasis role="bold">m_ReadLock</emphasis> on the object <emphasis role="bold">m_Socket</emphasis>.</para>
        </listitem>
        <listitem>
          <para>If an <emphasis role="bold">object </emphasis>is ever exposed outside of the class, a client application may use that <emphasis role="bold">object </emphasis>as a <emphasis role="bold">lock </emphasis>handle. If we have our own <emphasis role="bold">lock </emphasis>object, there can be no additional side effects.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Locks shall be readonly</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0133; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Status: Proposed; Version: 1.0; Created: 2017-02-15 21:30:20Z; Modified: 2019-11-02 12:47:48Z.</emphasis>
        </superscript>
      </para>
      <para>A <emphasis role="bold">lock </emphasis>object should be marked as <emphasis role="bold">readonly </emphasis>and initialized as an object in the constructor.</para>
      <para>This prevents a <emphasis role="bold">lock object </emphasis>from being reassigned, ensuring that the <emphasis role="bold">lock object</emphasis> remains constant throughout the lifetime of a class.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>Often a collection <emphasis role="bold">object </emphasis>is also its own <emphasis role="bold">lock </emphasis>to synchronize modification to it. If in an add/remove operation we <emphasis role="bold">lock </emphasis>the collection, but in a <emphasis role="bold">Reset </emphasis>method we were to simply create a new instance, current locks are invalid and may lead to obscure race conditions.</para>
      <para>By making a dedicated <emphasis role="bold">lock object</emphasis>, we avoid this problem (CREQ0132), but if the collection were marked <emphasis role="bold">readonly</emphasis>, the compiler would complain if the collection object were to be reassigned.</para>
      <para>If for legacy reasons it's not easy to create a new lock, simply assigning objects as <emphasis role="bold">readonly </emphasis>which are used as locks may help to identify unidentified bugs.</para>
    </section>
  </section>
  <section>
    <title>Tasks and Parallel Programming</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0330; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-12-15 20:44:02Z; Modified: 2019-12-15 20:49:37Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Prefer async/await over BeginXXX and EndXXX</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0333; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-12-15 20:50:22Z; Modified: 2019-12-15 20:51:43Z.</emphasis>
        </superscript>
      </para>
      <para>The usage of <emphasis role="bold">Task </emphasis>and the <emphasis role="bold">async </emphasis>and <emphasis role="bold">await </emphasis>keywords is much more readable than the usage of <emphasis role="bold">BeginXXX </emphasis>and <emphasis role="bold">EndXXX</emphasis></para>
      <para>Libraries targeted for .NET 4.0 and earlier cannot use the <emphasis role="bold">async </emphasis>and <emphasis role="bold">await </emphasis>keywords (only formally introduced and working in .NET 4.5).</para>
    </section>
    <section>
      <title>Never Use Referenced Parameters for output</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0332; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-12-15 20:47:40Z; Modified: 2019-12-20 14:42:14Z.</emphasis>
        </superscript>
      </para>
      <para>Avoid the usage of referenced parameters (usage of the <emphasis role="bold">ref </emphasis>or <emphasis role="bold">out </emphasis>keyword) for operations that do not complete immediately.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>These operations cannot be easily rewritten in an asynchronous programming model using either <emphasis role="bold">BeginXXX</emphasis>/<emphasis role="bold">EndXXX</emphasis> or <emphasis role="bold">Task</emphasis>. Even when doing so requires an implementation where the asynchronous methods look and behave differently to the synchronous methods.</para>
    </section>
    <section>
      <title>Tuples</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0334; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-12-20 14:42:17Z; Modified: 2019-12-20 14:46:09Z.</emphasis>
        </superscript>
      </para>
      <para>Consider using <emphasis role="bold">Tuples </emphasis>in C# 7.1 when using the <emphasis role="bold">async </emphasis>programming model instead of <emphasis role="bold">ref </emphasis>or <emphasis role="bold">out</emphasis>.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>Often when functions return results as a reference parameter (with the out keyword), it is because the result of the function call might return the success of the operation (to avoid unnecessarily raising exceptions).</para>
      <para>Rewriting the method to return Tuples instead can keep code compact and readable and avoid having to create "mini" structs or classes just to contain a small number of return values.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <para>The following method attempts to get the branch name, with the result code indicating if the call was successful, and if so, then the name of the branch. </para>
      <screen>bool GetBranch(string path, out string branch);</screen>
      <para>This could be rewritten as:</para>
      <screen>Task&lt;(bool success, string branch)&gt; GetBranchAsync(string path);</screen>
    </section>
  </section>
  <section>
    <title>Synchronization</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0313; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-04 19:55:56Z; Modified: 2019-11-04 19:56:02Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Thread.Resume and Thread.Suspend</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0314; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-04 19:56:04Z; Modified: 2019-11-04 19:58:53Z.</emphasis>
        </superscript>
      </para>
      <para>Do not use <emphasis role="bold">Thread.Suspend</emphasis> or <emphasis role="bold">Thread.Resume</emphasis> to manage your threads. Synchronize threads using <emphasis role="bold">WaitHandle </emphasis>objects and loops.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>Using <emphasis role="bold">Thread.Suspend</emphasis> and <emphasis role="bold">Thread.Resume</emphasis> doesn't allow any control when a thread is suspended or resumed. It could do so in the middle of a lock, including a lock that is system wide in the framework or in the Operating System. Suspending may occur and block all other threads unexpectedly, including unmanaged locks.</para>
      <para>Also, when a thread is suspended, a call to <emphasis role="bold">Thread.Abort</emphasis> may raise an exception in .NET for WIndows, or can be simply ignored under Mono. The behavior in this case is not well defined.</para>
    </section>
    <section>
      <title>Thread.Sleep</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0315; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-04 19:59:00Z; Modified: 2019-11-04 20:08:49Z.</emphasis>
        </superscript>
      </para>
      <para>Do not use <emphasis role="bold">Thread.Sleep</emphasis> for synchronizing different portions of code. All code must be properly synchronized using synchronization mechanisms provided in the run-time.</para>
      <para>Often, an object might need to sleep for some period of time as it waits for external events. Use <emphasis role="bold">WaitHandle.Wait()</emphasis> methods with timeouts, especially on <emphasis role="bold">ManualResetEvent </emphasis>objects. Quite often, your class may be requested to dispose during a sleep operation, which when using <emphasis role="bold">WaitHandle.Wait()</emphasis> can be easily interrupted.</para>
      <para>Using <emphasis role="bold">Thread.Sleep</emphasis> often leads to test case failures as timeouts occur, or the system is sporadically overloaded. Software should be able to function properly even if under heavy load, something that the <emphasis role="bold">Thread.Sleep</emphasis> doesn't allow.</para>
      <para>
        <emphasis role="bold">Thread.Sleep</emphasis> never guarantees how long it will sleep, only that the thread is slept for at least the timeout specified, but it can be significantly longer.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <para>In this fictitious (and incomplete) example, code might be sleeping, until it performs the next operation. If however it is sleeping in a long operation and it is told to <emphasis role="bold">Dispose()</emphasis>, it can abort the sleep and clean up, setting the object <emphasis role="bold">m_Closed</emphasis> when done. Thus everything is properly synchronized and no sleep operation is performed.</para>
      <screen>ManualResetEvent m_Close = new ManualResetEvent(false);

...
private bool Sleep(int timeout) {
  // Sleep and wait for an answer, unless aborted
  return m_Close.Wait(timeout);
}

protected virtual void Dispose(bool disposing) {
  if (!disposing) return;
  m_Close.Set();
  m_Closed.Wait(-1);
}</screen>
    </section>
    <section>
      <title>Do Not Synchronize on Operating System Real-Time Clock</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0316; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-04 20:08:56Z; Modified: 2019-11-04 20:11:18Z.</emphasis>
        </superscript>
      </para>
      <para>Never base sleep periods based on the Operating System Clock. Always use Operating System primitives that are based on the internal monotonic clock that is not at all related to the CMOS real-time clock.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>The real-time clock is never guaranteed to be monotonic (e.g. Daylight savings can cause the clock to roll back), and never guaranteed to be a measure of real time of when your process is running. There are many situations that can distort the clock such as:</para>
      <itemizedlist>
        <listitem>
          <para>Time synchronization services, such as Windows Time, or NTP</para>
        </listitem>
        <listitem>
          <para>Daylight Savings changes</para>
        </listitem>
        <listitem>
          <para>System Suspend and Resume</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Safe Handles</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0070; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:00:12Z; Modified: 2017-12-26 15:50:46Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Unmanaged Handles</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0071; Author: jcurl; Stereotype: Functional; Status: Proposed; Version: 1.0; Created: 2015-11-10 20:56:22Z; Modified: 2019-12-15 20:43:05Z.</emphasis>
        </superscript>
      </para>
      <para>Unmanaged handles should be abstracted using a new class deriving from the <emphasis role="bold">SafeHandle </emphasis>object.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>
        <emphasis role="bold">SafeHandle</emphasis>s correctly implement reference counting, especially when using P/Invoke so that in case of unexpected errors (stack overflow, memory exceptions, thread abortion, etc.) the reference counter is still properly decremented avoiding memory leaks.</para>
    </section>
    <section>
      <title>DangerousGetHandle</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0150; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Stereotype: Functional; Status: Proposed; Version: 1.0; Created: 2017-12-26 15:52:17Z; Modified: 2019-11-02 12:48:14Z.</emphasis>
        </superscript>
      </para>
      <para>Do not use <emphasis role="bold">DangerousGetHandle</emphasis>.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>A <emphasis role="bold">SafeHandle </emphasis>(and objects derived thereof) properly implement reference counting. By passing a handle retrieved using <emphasis role="bold">DangerousGetHandle</emphasis>, there is no guarantee that the <emphasis role="bold">SafeHandle </emphasis>is disposed/closed of while it is still in use due to lack of reference counting.</para>
      <para>To use <emphasis role="bold">DangerousGetHandle</emphasis>, you must use Constrained Execution Regions (CERs) properly and manually implement the reference counting with the <emphasis role="bold">SafeHandle</emphasis>.</para>
    </section>
  </section>
  <section>
    <title>Exceptions</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0072; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 20:57:14Z; Modified: 2015-11-10 20:57:16Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Naming</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0073; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 20:57:19Z; Modified: 2017-12-26 14:52:34Z.</emphasis>
        </superscript>
      </para>
      <para>Exceptions should end with the noun Exception.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <screen>MyErrorException</screen>
    </section>
    <section>
      <title>Implementation</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0074; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 20:58:02Z; Modified: 2019-11-02 12:48:21Z.</emphasis>
        </superscript>
      </para>
      <para>Exceptions shall be public and inherit from the <emphasis role="bold">System.Exception </emphasis>object.</para>
    </section>
    <section>
      <title>Serializable</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0075; Author: jcurl; Stereotype: Functional; Status: Proposed; Version: 1.0; Created: 2015-11-10 20:59:30Z; Modified: 2019-11-02 15:33:00Z.</emphasis>
        </superscript>
      </para>
      <para>Make exceptions serializable. An exception must be serializable to work correctly across application domain and remoting boundaries.</para>
    </section>
    <section>
      <title>Program Execution Flow</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0076; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:45:01Z; Modified: 2019-11-02 12:48:33Z.</emphasis>
        </superscript>
      </para>
      <para>Exceptions should not be used to change the flow of a program as part of ordinary execution. Exceptions should only be used to report and handle error conditions.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>A common debugging technique is for applications to attach to the <emphasis role="bold">Domain.FirstChanceException</emphasis> handler. They might log exceptions in a local buffer, or write to a log file as required for later analysis as part of debugging.</para>
      <para>Raising unnecessary exceptions requires the application programmer to build in special checks to reduce log size.</para>
      <para>Raising unnecessary exceptions has therefore a real performance impact. Exceptions should not be raised, especially if it might be used within a loop. These performance impacts are often observed also when running in the Visual Studio IDE debugger, as exceptions are also caught and logged, resulting in non-release code being not debuggable due to performance reasons.</para>
    </section>
    <section>
      <title>Returning Exceptions</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0077; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:45:34Z; Modified: 2015-11-10 21:45:52Z.</emphasis>
        </superscript>
      </para>
      <para>Exceptions should not be returned as a return value or parameter instead of being thrown.</para>
    </section>
    <section>
      <title>System Exceptions</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0078; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:46:05Z; Modified: 2022-06-29 21:28:24Z.</emphasis>
        </superscript>
      </para>
      <para>Do not throw <emphasis role="bold">System.Exception</emphasis>, <emphasis role="bold">System.SystemException</emphasis>, <emphasis role="bold">System.NullReferenceException</emphasis>, <emphasis role="bold">System.OutOfMemoryException</emphasis> or <emphasis role="bold">System.IndexOutOfRangeException</emphasis> intentionally from your own source code.</para>
    </section>
    <section>
      <title>Debug and Release Mode</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0079; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:46:21Z; Modified: 2015-11-10 21:46:28Z.</emphasis>
        </superscript>
      </para>
      <para>Do not create exceptions that can be thrown in debug mode but not release mode. To identify run-time errors during the development phase, use Debug Assert instead.</para>
    </section>
    <section>
      <title>Deriving Exceptions</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0080; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:47:46Z; Modified: 2019-11-02 12:48:59Z.</emphasis>
        </superscript>
      </para>
      <para>Derive exceptions from <emphasis role="bold">System.Exception</emphasis> or one of the other common base exceptions.</para>
    </section>
    <section>
      <title>Extra Information</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0081; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:48:38Z; Modified: 2015-11-10 21:48:44Z.</emphasis>
        </superscript>
      </para>
      <para>Consider providing exception properties for programmatic access to extra information (besides the message string) relevant to the exception.</para>
    </section>
  </section>
  <section>
    <title>Events</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0082; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:31:16Z; Modified: 2015-11-10 21:31:19Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Implementing IDispose</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0083; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:31:21Z; Modified: 2019-11-02 12:49:06Z.</emphasis>
        </superscript>
      </para>
      <para>If your object is long lived, but the subscriber of the event is short lived, implement the <emphasis role="bold">IDispose </emphasis>interface on the subscriber object, so that removal of the event is controlled.</para>
      <para>This is a very subtle memory leak in the .NET framework that has memory impact (the objects cannot be freed due to a strong reference from the no longer referenced short lived subscriber object to the long lived referenced object).</para>
      <para>There is also a potential performance impact, that the no longer referenced subscriber will still have its event called, even though it's no longer required.</para>
    </section>
    <section>
      <title>EventArgs</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0084; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:36:26Z; Modified: 2019-11-02 12:49:14Z.</emphasis>
        </superscript>
      </para>
      <para>Event Argument objects should derive from <emphasis role="bold">System.EventArgs</emphasis> and end with <emphasis role="bold">EventArgs </emphasis>in the name.</para>
    </section>
    <section>
      <title>Generic EventHandler&lt;T&gt;</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0085; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:37:59Z; Modified: 2019-11-02 12:49:30Z.</emphasis>
        </superscript>
      </para>
      <para>The definition of events should use the Generic <emphasis role="bold">EventHandler&lt;EventArgs&gt;</emphasis> form.</para>
      <screen>public event EventHandler&lt;MyEventArgs&gt; MyEvent;</screen>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>See MSDN CA1003. Before .NET Framework 2.0, in order to pass custom information to the event handler, a new delegate had to be declared that specified a class that was derived from the <emphasis role="bold">System.EventArgs</emphasis> class. This is no longer true in .NET Framework 2.0, which introduced the <emphasis role="bold">System.EventHandler&lt;TEventArgs&gt;</emphasis> delegate. This generic delegate allows any class that is derived from <emphasis role="bold">EventArgs </emphasis>to be used together with the event handler.</para>
    </section>
    <section>
      <title>Non-Generic EventHandler</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0086; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-16 21:19:16Z; Modified: 2019-11-02 12:49:38Z.</emphasis>
        </superscript>
      </para>
      <para>It's recommended to use the generic version in preference of the non-generic derived event handler. None-the-less, if a non-generic event handler is used, it shall end in the noun <emphasis role="bold">EventHandler</emphasis>.</para>
      <para>See Rule MSDN CA1003, which suggests not to use this.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <itemizedlist>
        <listitem>
          <para>MyEventHandler</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Event Naming</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0087; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:39:14Z; Modified: 2019-11-02 12:49:44Z.</emphasis>
        </superscript>
      </para>
      <para>Events in assemblies should generally be a verb and end with <emphasis role="bold">Event </emphasis>in the name.</para>
      <para>A general exception to this rule are Windows Forms controls.</para>
    </section>
    <section>
      <title>OnEvent Protected Method</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0088; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:41:00Z; Modified: 2019-11-02 12:50:15Z.</emphasis>
        </superscript>
      </para>
      <para>For objects that implement events that can be inherited, they should also implement a <emphasis role="bold">bprotected virtual</emphasis> method for calling the <emphasis role="bold">event </emphasis>as in the example.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <screen>public event EventHandler&lt;MyEventArgs&gt; MyEvent;

protected virtual void OnMyEvent(object sender, MyEventArgs args) {
  EventHandler&lt;MyEventArgs&gt; handler = MyEvent;
  if (handler != null) {
    handler(sender, args);
  }
}</screen>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>Overriding a <emphasis role="bold">class </emphasis>and an <emphasis role="bold">OnXXEvent</emphasis></para>
      <para>
        <emphasis role="bold">virtual </emphasis>method is significantly faster than subscribing to the appropriate <emphasis role="bold">event</emphasis>.</para>
      <para>
        <emphasis role="bold">Note</emphasis>:</para>
      <para>The assignment of the <emphasis role="bold">event</emphasis>, followed by the check to <emphasis role="bold">null </emphasis>is to avoid a race condition should the event handler be modified between the check if the event is defined and the invocation of that event.</para>
      <section>
        <title>Null-Conditional Operator</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0142; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2017-08-12 18:43:19Z; Modified: 2019-11-02 11:53:13Z.</emphasis>
          </superscript>
        </para>
        <para>Usage of the null-conditional operator should be consistent with the project in use. That is, the alternative form should be used when it is consistent with the existing project.</para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <para>Using the null-conditional:</para>
        <screen>protected virtual void OnMyEvent(object sender, MyEventArgs args) {
  MyEvent?.Invoke(sender, args);
}</screen>
        <para>Using the C# 4.0 notation</para>
        <screen>protected virtual void OnMyEvent(object sender, MyEventArgs args) {
  EventHandler&lt;MyEventArgs&gt; handler = MyEvent;
  if (handler != null) {
    handler(sender, args);
  }
}</screen>
        <para>Preference is for the C# 4.0 notation as it is more explicit.</para>
      </section>
      <section>
        <title>Sender in Protected OnEvent Method Signature</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0143; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2017-08-12 18:43:52Z; Modified: 2019-11-02 12:51:27Z.</emphasis>
          </superscript>
        </para>
        <para>Your protected methods should generally have the sender in the signature.</para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <screen>protected virtual void OnMyEvent(object sender, MyEventArgs args) {
  EventHander&lt;MyEventArgs&gt; handler = MyEvent;
  if (handler != null) handler(sender, args);
}</screen>
        <para>
          <emphasis role="bold">Rationale</emphasis>:</para>
        <para>Much example code has functionality such as:</para>
        <screen>protected virtual void OnMyEvent(MyEventArgs args) {
  EventHander&lt;MyEventArgs&gt; handler = MyEvent;
  if (handler != null) handler(sender, args);
}</screen>
        <para>This has disadvantages for chaining events from other classes (a chaining function needs to be written to explicitly catch an event and to raise the protected method), where if the protected method already contains the signature for a typical event handler it can serve two purposes.</para>
        <para>A second example is that often it might be useful to propagate the sender of the actual event when chaining to the user, rather than the final object of the event chain, especially if the original event is also public.</para>
      </section>
      <section>
        <title>Exception in Signature to OnXXXEvent Protected Method</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0158; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Stereotype: Functional; Status: Proposed; Version: 1.0; Created: 2017-12-26 17:31:45Z; Modified: 2019-11-02 11:52:34Z.</emphasis>
          </superscript>
        </para>
        <para>Protected override methods should have the <emphasis role="bold">EventArgs </emphasis>in the signature. Exceptions are allowed if they're used in standard practice.</para>
        <para>
          <emphasis role="bold">Rationale</emphasis>:</para>
        <para>Some framework instances have different practices. Coding standards should avoid confusion and present a consistent way of doing things, and if a framework has established a different mechanism, that should be used instead.</para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <para>The <emphasis role="bold">INotifyPropertyChanged </emphasis>interface defining the <emphasis role="bold">PropertyChanged </emphasis>event usually has the associated protected method defined within the implementing classes:</para>
        <screen>protected virtual void OnPropertyChanged(string propertyName) {
  …
}</screen>
        <para>and should be used instead of:</para>
        <screen>protected virtual void OnPropertyChanged(PropertyChangedEventArgs e) {
  …
}</screen>
      </section>
    </section>
    <section>
      <title>Pre-Events and Post-Events</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0089; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-16 21:21:22Z; Modified: 2017-08-12 18:27:41Z.</emphasis>
        </superscript>
      </para>
      <para>Name the events when closing based on the "gerund" form for the pre-event (words usually ending in -ing).</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <itemizedlist>
        <listitem>
          <para>Closing (pre-event) and Closed (post-event).</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Streams</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0090; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:49:34Z; Modified: 2015-11-10 21:49:36Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Naming</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0091; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:49:38Z; Modified: 2019-11-02 12:52:08Z.</emphasis>
        </superscript>
      </para>
      <para>Stream types shall end with the noun <emphasis role="bold">Stream</emphasis>.</para>
    </section>
    <section>
      <title>Simultaneous Reading and Writing</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0092; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 21:50:19Z; Modified: 2019-11-02 11:52:11Z.</emphasis>
        </superscript>
      </para>
      <para>The .NET implementation of a stream doesn't support simultaneous reading and writing from a stream. If this is required, explicit implementation of <emphasis role="bold">BeginRead </emphasis>and <emphasis role="bold">EndRead </emphasis>are required.</para>
      <para>If your stream is full duplex, that is, reading and writing are expected to work in parallel and are independent of each other, deadlocks may occur when using the default implementation. These deadlocks are by design in Microsoft's implementation</para>
      <para>For more information, see: http://www.codeproject.com/Tips/575618/Avoiding-Deadlocks-with-System-IO-Stream-BeginRead</para>
    </section>
  </section>
  <section>
    <title>Attributes</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0093; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-16 21:16:08Z; Modified: 2019-11-02 12:52:28Z.</emphasis>
      </superscript>
    </para>
    <para>Attribute classes deriving from <emphasis role="bold">System.Attribute</emphasis> must always end with <emphasis role="bold">Attribute</emphasis>.</para>
    <para>
      <emphasis role="bold">Example</emphasis>:</para>
    <screen>public class TestAttribute : System.Attribute { }</screen>
  </section>
  <section>
    <title>Abstract Classes</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0138; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2017-08-12 18:19:48Z; Modified: 2017-08-12 18:19:53Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Object Oriented Design</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0139; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2017-08-12 18:20:26Z; Modified: 2019-11-02 12:52:59Z.</emphasis>
        </superscript>
      </para>
      <para>An <emphasis role="bold">abstract class </emphasis>should be used when it is expected that the class always be derived from (i.e. it is always a base class). An<emphasis role="bold"> abstract class</emphasis> isn't required to have <emphasis role="bold">abstract </emphasis>methods or properties.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>Having a <emphasis role="bold">public class</emphasis> with <emphasis role="bold">protected </emphasis>constructors may appear to satisfy similar requirements, but a derived class can still instantiate a <emphasis role="bold">public class</emphasis> with a <emphasis role="bold">protected </emphasis>constructor in its own constructor, thus probably violating the intended design requirement that the base class must be derived from as in the following example:</para>
      <screen>public void Base {
  protected Base() {
    // ...
  }
}

public void Derived : Base {
  public Derived() {
    // Here we instantiate the base, not allowed if the base
    // would be abstract
    var b = new base();
  }
}</screen>
    </section>
    <section>
      <title>Abstract Class Constructors</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0140; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2017-08-12 18:21:30Z; Modified: 2019-11-02 12:53:07Z.</emphasis>
        </superscript>
      </para>
      <para>An <emphasis role="bold">abstract class</emphasis> should only have constructors that are <emphasis role="bold">protected</emphasis>.</para>
      <para>See CA1012: Abstract types should not have constructors.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</para>
    </section>
    <section>
      <title>Abstract vs. Interfaces</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0141; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2017-08-12 18:30:12Z; Modified: 2019-11-02 12:53:55Z.</emphasis>
        </superscript>
      </para>
      <para>Interfaces shall be used in preference to <emphasis role="bold">abstract classes</emphasis> when the implementation is unimportant. Almost all cases should interfaces be used for public APIs. An interface is a totally abstract set of members that can be thought of as defining a contract for conduct. The implementation of an interface is left completely to the developer.</para>
      <para>Classes can inherit from multiple interfaces.</para>
      <para>Abstract classes define a partial or a full implementation, thereby encapsulating common functionality for inherited classes. It is only possible for a class to inherit from a single base class.</para>
      <para>To decide which should be used:</para>
      <itemizedlist>
        <listitem>
          <para>If the functionality you are creating will be useful across a wide range of disparate objects, use an <emphasis role="bold">interface</emphasis>. Abstract classes should be used primarily for objects that are closely related, whereas interfaces are best suited for providing a common contract to unrelated classes.</para>
        </listitem>
        <listitem>
          <para>If you are designing small, concise bits of functionality, use <emphasis role="bold">interface</emphasis>s. If you are designing large functional units, use an <emphasis role="bold">abstract class</emphasis>.</para>
        </listitem>
        <listitem>
          <para>If you want to provide common, implemented functionality among all implementations of your component, use an<emphasis role="bold"> abstract class</emphasis>. Abstract classes allow you to partially implement your class, whereas interfaces contain no implementation for any members.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Single Responsibility Principle</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0156; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Status: Proposed; Version: 1.0; Created: 2017-12-26 16:22:26Z; Modified: 2019-11-02 12:54:00Z.</emphasis>
      </superscript>
    </para>
    <para>Classes should be designed to perform one task.</para>
    <para>
      <emphasis role="bold">Example</emphasis>:</para>
    <para>See also the Dispose pattern, separating managed and unmanaged behavior.</para>
    <para>
      <emphasis role="bold">Rationale</emphasis>:</para>
    <para>The Single Responsibility Principle increases testability, maintainability and readability of code.</para>
    <section>
      <title>Responsibility and Policy</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0157; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Status: Proposed; Version: 1.0; Created: 2017-12-26 16:25:24Z; Modified: 2017-12-26 16:32:28Z.</emphasis>
        </superscript>
      </para>
      <para>Policy should be the responsibility of the upper layers of a design. Lower layers should implement functionality.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <para>Maintaining a configuration file should have multiple classes:</para>
      <itemizedlist>
        <listitem>
          <para>Reading the file, if it fails it should indicate a failure. Defaults should not be returned as this could be considered policy</para>
        </listitem>
        <listitem>
          <para>The class for maintaining the configuration should be different to how it is serialized, or deserialized to/from disk.</para>
        </listitem>
        <listitem>
          <para>Creating a default configuration. The application can decide to create defaults in case of an error, but also notify the user.</para>
        </listitem>
        <listitem>
          <para>A configuration can be broken down into smaller classes as required for separate functionality</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>The Model</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0094; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-30 21:21:28Z; Modified: 2015-11-30 21:29:40Z.</emphasis>
      </superscript>
    </para>
    <para>All software designs, from small to large should consider an architecture model that is suitable for the application being developed.</para>
    <para>A small application should have a minimal model, typically the presentation layer separating from logic that manages the data.</para>
    <para>GUI applications should consider the Model-View-Presenter (Windows Forms) or Model-View-View-Model (Windows Presentation Foundation). Whether an application uses a supporting framework, such as the Entity framework is a matter of expected scope and side of the application. If a model is too complicated for the application, more work is spent in building the infrastructure than implementing the relatively small feature scope. Too simple a model, and the more complicated it is to maintain that application among larger teams.</para>
    <section>
      <title>Small and Simple Applications - The Model folder</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0095; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-30 21:29:42Z; Modified: 2019-11-02 12:54:31Z.</emphasis>
        </superscript>
      </para>
      <para>Small applications, even Console applications should separate the presentation layer (console output, or Windows forms code) against the logic that makes decisions.</para>
      <para>The logic that defines the behavior of the application should be in the <emphasis role="bold">Model</emphasis> folder.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>As an example, consider the Windows Forms application that is relatively small to simply parse a file and then to output into a different file. If the parsing is implemented using a model approach with a well thought out design at the beginning, converting the Windows application to also support a console mode is simple - a set sequence of commands are executed in a small function to read the file, parse the file, then save the converted file. If done correctly, the effort is very small.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>Unit Testing support is increased significantly by separating the GUI from the model. By having logic in the model, it is much easier to target unit tests and ensure that the system behaves as expected. The presentation layer is smaller and only needs to deal with logic related to the GUI or the presentation to the user.</para>
    </section>
  </section>
  <section>
    <title>Object Oriented Design</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0324; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-15 07:17:50Z; Modified: 2019-11-15 07:17:55Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Object Inheritance and Code Reuse</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0325; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-15 07:18:01Z; Modified: 2019-11-15 07:25:57Z.</emphasis>
        </superscript>
      </para>
      <para>Object Oriented Design is a design methodology, of which inheritance has a meaning. Use object inheritance to describe relationships between objects.</para>
      <para>However it is often used just for the purpose of code reuse.</para>
      <para>Reconsider the use of object inheritance if it is only for the purpose of code reuse. There are often other techniques (composition, static helper methods) that may be more suitable.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>If <emphasis role="bold">class B</emphasis> derives from <emphasis role="bold">class A</emphasis>, it is said that B is an A, but A is not a B. If in the real world modelling this is not the case, then do not use Object Inheritance to describe this.</para>
      <para>Consider if there is a fundamental object and model it that way, as a user would expect, not how a programmer can reuse code which the user doesn't see anyway.</para>
      <para>So do not allow the implementation to influence the design and thus leading to confusion of the user.</para>
    </section>
    <section>
      <title>Extending Objects and the Open/Closed Principle</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0326; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-15 07:26:04Z; Modified: 2019-11-15 07:52:49Z.</emphasis>
        </superscript>
      </para>
      <para>The Open/Closed principle from S.O.L.I.D. says to write code that it's easy to add new functionality without modifying existing code. That prevents situations in which a change to one of your classes also requires you to adapt all depending classes.</para>
      <para>However, be warned that software inheritance also introduces tight coupling if the subclasses depend on implementation details of their parent class.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <para>A basic buffer data class provides an implementation wrapped around an array. It has an indexer and a length.</para>
      <screen>public Buffer {
  print int[] m_Array;

  public Buffer(int length) {
    m_Array = new int[length];
  }

  public virtual int Length { get { return m_Array.Length; } }

  public virtual int GetValue(int index) {
    if (index &lt; 0 || index &gt;= Length)
      throw new ArgumentOutOfRangeException();
    return m_Array[index];
  }</screen>
      <screen>  public int GetSum() {
    int sum;
    for (int i = 0; i &lt; Length; i++)
      sum += m_Array[i];
    return sum;
  }
}</screen>
      <para>Then a derived class is created which keeps the semantics, so it can be used in the place of every class requiring <emphasis role="bold">Buffer</emphasis>, but allows two arrays to still look like a continuous block of memory, the first array is maintained as part of <emphasis role="bold">Buffer</emphasis>, the second array is created in the derived class. The <emphasis role="bold">Length </emphasis>for the derived class is now the sum of both arrays.</para>
      <para>The base class <emphasis role="bold">Buffer </emphasis>uses the property <emphasis role="bold">Length </emphasis>internally. When overriding the class <emphasis role="bold">Buffer</emphasis>, one must now be aware of the details that the base class may now have its behaviour changed through the derived class unexpectedly, and requires intimate knowledge of the base class to extend.</para>
      <para>So the derived class overrides Length to be:</para>
      <screen>public override int Length {
  get { return base.Length + m_SecondArray.Length; }
}</screen>
      <para>But as you can see, the implementation of GetSum() is now broken.</para>
      <para>
        <emphasis role="bold">Solution</emphasis>:</para>
      <para>Consider the Polymorphic Open/Closed principle. Derive from interfaces or very simple abstract base classes and consider composition instead of inheritance. This adds an additional level of abstraction which enables loose coupling. </para>
      <para>If sharing code via inheritance, design the classes so that base classes override <emphasis role="bold">protected virtual </emphasis>methods instead of <emphasis role="bold">public virtual</emphasis> methods. The base class allows extension only via the <emphasis role="bold">protected </emphasis>methods.</para>
      <para>An example of this is the Microsoft <emphasis role="bold">Collection&lt;T&gt;</emphasis> class.</para>
    </section>
  </section>
</chapter>
<chapter>
  <title>Public Documentation</title>
  <para>
    <superscript>
      <emphasis>Requirement: CREQ0096; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-06-15 15:29:26Z; Modified: 2015-11-09 08:38:06Z.</emphasis>
    </superscript>
  </para>
  <section>
    <title>Assembly Public Documentation for Framework Components</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0097; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-06-15 15:29:34Z; Modified: 2015-11-09 08:38:18Z.</emphasis>
      </superscript>
    </para>
    <para>XML documentation shall be provided for all API framework components.</para>
  </section>
  <section>
    <title>SHFB</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0098; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-06-15 15:30:13Z; Modified: 2019-11-01 21:32:01Z.</emphasis>
      </superscript>
    </para>
    <para>The build system for API documentation shall be SHFB (Sandcastle Help File Builder) by Eric Woodruff.</para>
    <para>Results shall be in HTML and MSHELP 2.x format compatible with Visual Studio 2017.</para>
  </section>
  <section>
    <title>Build Conditions</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0099; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-06-15 15:30:44Z; Modified: 2015-11-09 08:38:21Z.</emphasis>
      </superscript>
    </para>
    <para>There shall be no warnings generated during the build process for Release for API documentation for framework components.</para>
    <para>There shall be no warnings or errors generated when building using the current version of SHFB.</para>
  </section>
  <section>
    <title>Spelling and Grammar</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0100; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-06-15 15:34:16Z; Modified: 2017-08-12 20:58:01Z.</emphasis>
      </superscript>
    </para>
    <para>All public documentation shall be in English. The dialect of english shall be consistent with the project (either British en-GB or American en-US).</para>
    <para>For example, the Automation framework uses en-US.</para>
    <para>Sentences shall be properly terminated with a period, and grammar should generally be correct.</para>
    <para>The language shall be clear, concise and understandable. If examples make the concept clearer, examples should be provided.</para>
  </section>
</chapter>
<chapter>
  <title>Testing</title>
  <para>
    <superscript>
      <emphasis>Requirement: CREQ0101; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:47:52Z; Modified: 2017-08-12 18:58:01Z.</emphasis>
    </superscript>
  </para>
  <section>
    <title>The Model</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0103; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-30 21:34:17Z; Modified: 2017-12-26 14:54:28Z.</emphasis>
      </superscript>
    </para>
    <para>By applying the model approach, as discussed in the section for Design Patterns makes it much easier to unit test.</para>
    <para>
      <emphasis role="bold">Rationale</emphasis>:</para>
    <para>Applying tests to a model promotes a better design and software architecture. Methods are smaller to make it easier to write unit test code for. Smaller and better defined methods reduce cyclomatic complexity reducing the chance of defects in software and making code easier to read.</para>
    <section>
      <title>Application Methods should be Public</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0104; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-30 21:37:23Z; Modified: 2019-11-02 12:54:57Z.</emphasis>
        </superscript>
      </para>
      <para>The methods being tested in the EXE should be <emphasis role="bold">public</emphasis>, to make it easier to test without having to resort to reflection and other difficult to read constructs.</para>
    </section>
    <section>
      <title>Appropriate Model</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0145; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2017-08-12 18:58:57Z; Modified: 2017-08-12 19:00:12Z.</emphasis>
        </superscript>
      </para>
      <para>Applications and Framework libraries should follow an appropriate design pattern, that is suited for testability, even if relatively small.</para>
      <section>
        <title>MVVM - Model View View Model</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0146; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2017-08-12 19:00:14Z; Modified: 2017-08-12 19:00:49Z.</emphasis>
          </superscript>
        </para>
        <para>WPF Projects should use the MVVM model. The Model and View Model should be testable.</para>
      </section>
      <section>
        <title>Domain Driven Design</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0147; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2017-08-12 19:00:51Z; Modified: 2017-08-12 19:02:05Z.</emphasis>
          </superscript>
        </para>
        <para>Applications and Frameworks should follow Domain Driven Design, separating Application, Business / Model, Storage and Infrastructure into separate layers, potentially separate assemblies for strict separation.</para>
        <para>Each class in each layer should be designed for testability.</para>
      </section>
    </section>
    <section>
      <title>Test Patterns</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0176; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-06-29 22:47:47Z; Modified: 2019-06-29 22:48:12Z.</emphasis>
        </superscript>
      </para>
      <para>There are many ways to write testable code, some listed in this section.</para>
      <section>
        <title>Inversion of Control</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0144; Author: jcurl; Stereotype: Functional; Status: Proposed; Version: 1.0; Created: 2017-08-12 18:54:20Z; Modified: 2019-06-29 22:48:14Z.</emphasis>
          </superscript>
        </para>
        <para>Software design should use Inversion of Control where appropriate to allow testability.</para>
        <para>
          <emphasis role="bold">Rationale</emphasis>:</para>
        <para>A class for implementing hardware diagnostics would have a class that necessarily requires information from hardware through specialized drivers. A business logic class might raise events depending on the data that is obtained. Testing can be challenging, especially if it requires specific hardware, or even more so difficult in error use cases.</para>
        <para>By using an interface to abstract the hardware and allowing the business logic class to program against an interface instead of a specific implementation, a test case can be written to simulate error conditions without the need for specific hardware.</para>
      </section>
      <section>
        <title>Factories and Interfaces</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0175; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Stereotype: Functional; Status: Proposed; Version: 1.0; Created: 2019-06-29 22:46:31Z; Modified: 2019-06-29 22:50:40Z.</emphasis>
          </superscript>
        </para>
        <para>Software design should use the Factory pattern to allow a test case to generate their own test objects for mocking.</para>
        <para>
          <emphasis role="bold">Rationale</emphasis>:</para>
        <para>By using the factory pattern, the "Program" can initialize factories required for real work. Factories should implement an interface that a test program can write their own factory to replace functionality for mocking.</para>
        <para>For example, a factory can create a class that can serialize an object to disk. A test program might want to replace this factory with its own, so that when the main application serializes to disk, the test class generated by the test factory raises a file system exception, otherwise exceptionally difficult for all Operating Systems when done as an integration test.</para>
      </section>
    </section>
  </section>
  <section>
    <title>Unit Testing</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0102; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-25 22:06:01Z; Modified: 2019-11-02 12:55:47Z.</emphasis>
      </superscript>
    </para>
    <para>Unit Testing should be performed on the main executable as well as on any assemblies that are being used.</para>
    <para>The major benefits of unit testing for design are:</para>
    <itemizedlist>
      <listitem>
        <para>Early refactoring of the software to allow for a clean design that can be unit tested. This reduces the size of the functions, reducing the cyclomatic complexity.</para>
      </listitem>
      <listitem>
        <para>Allow early capture of breaking changes, either to framework functionality or classes that are used in other locations.</para>
      </listitem>
      <listitem>
        <para>Check functionality again after refactoring</para>
      </listitem>
      <listitem>
        <para>Provide documentation in the form of code on how a class is expected to be used, by the way that a Unit test manipulates it.</para>
      </listitem>
    </itemizedlist>
    <para>Advantages of Unit Testing for cross development are:</para>
    <itemizedlist>
      <listitem>
        <para>Identify differences between operating systems and their behavior, and ensure the behavior of a class is consistent regardless of the Operating System.</para>
      </listitem>
      <listitem>
        <para>Allow for better planning and quicker porting of software to new Operating Systems or frameworks.</para>
      </listitem>
    </itemizedlist>
    <para>Portability is all the more important especially for supporting multiple Operating Systems.</para>
    <itemizedlist>
      <listitem>
        <para>There are always subtle differences between the actual operating systems being used. For example, networking on Windows XP might return different results than networking on Windows 7 due to the differences in the underlying network libraries.</para>
      </listitem>
      <listitem>
        <para>The Mono Framework on Linux is changing at a rapid pace, especially with the .NET core being open sourced. It is easy to determine for the target platform if the system is likely to work, or if there is missing functionality, or a change in new functionality (especially through the <emphasis role="bold">PlatformNotSupportedException</emphasis>).</para>
      </listitem>
      <listitem>
        <para>Run unit tests, via the NUnit test binary, to identify issues early in an automatic way.</para>
      </listitem>
    </itemizedlist>
    <section>
      <title>Test Project Structure</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0190; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 10:36:00Z; Modified: 2019-11-02 10:38:47Z.</emphasis>
        </superscript>
      </para>
      <section>
        <title>Separate Production Code from Test Code</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0191; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 10:36:34Z; Modified: 2019-11-02 10:42:28Z.</emphasis>
          </superscript>
        </para>
        <para>A separate test project shall be created that is in parallel to the production code. Do not mix test code and production code in the same project file.</para>
        <para>
          <emphasis role="bold">Rationale</emphasis>:</para>
        <para>All test code, is by definition dead code (it is not used by the framework library) and should not be part of the product.</para>
        <para>In case that a platform is failing, it is easy to copy the code that performs the tests to the client platform and rerun. For example NUnit 2.6.x has minimum requirements of .NET 2.0, which is less than modern code, and so requires minimal, if at all, extra installation to run the tests.</para>
      </section>
      <section>
        <title>Directory, File and Class Structure</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0192; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 10:38:26Z; Modified: 2019-11-02 10:42:34Z.</emphasis>
          </superscript>
        </para>
        <para>The directory structure and class structure should mirror the structure of the code under test. There should be one test class for each class under test.</para>
        <para>Namespaces of the test class should be the same as the class under test.</para>
        <para>
          <emphasis role="bold">Rationale</emphasis>:</para>
        <para>When adding, modifying or removing code from a class, one should be able to quickly identify where the test code is maintained. This helps the developer reduce duplicated test code and by understanding the structure of the production code, test code can be easier understood.</para>
      </section>
    </section>
    <section>
      <title>NUnit Test Framework</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0105; Author: jcurl; Stereotype: Functional; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:47:59Z; Modified: 2019-11-02 12:56:50Z.</emphasis>
        </superscript>
      </para>
      <para>Software should use the NUnit Test Framework.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>The NUnit test framework is mature, used by Microsoft in the CoreFX project and is cross platform. It also offers a much richer set of features of MSTest. It is also the default test framework for Mono on other platforms.</para>
      <para>It can be installed using <emphasis role="bold">nuget</emphasis> within your assembly. The NUnit Test Adaptor works also in the VS2013 and later Community Editions. Even though it can't be used in the desktop editions, NUnit has a test framework that runs outside of the Visual Studio IDE.</para>
      <para>The current version is 2.6.7. The 3.x versions should not be used as they're not supported natively by MonoIDE 5.1 or earlier (at the time of writing). NUnit 3.x is not backward compatible to NUnit 2.6.7.</para>
      <para>Version 2.7.0 has some minor backward compatibility issues, and should probably not be used when upgrading, instead upgrade to NUnit 3.x.</para>
      <section>
        <title>Testing on Supported Platforms</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0106; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:49:47Z; Modified: 2017-08-19 21:18:06Z.</emphasis>
          </superscript>
        </para>
        <para>By using the NUnit Framework, you can also test your application software and frameworks on supported platforms without installing the IDE. Install the NUnit test application, which will work with .NET 2.0 and later.</para>
      </section>
      <section>
        <title>Writing Assertions</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0107; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:51:21Z; Modified: 2019-11-02 11:07:34Z.</emphasis>
          </superscript>
        </para>
        <para>You should write assertions using the new Constraint Model, otherwise known as Fluent style. The fluent style allows test cases to read similar to natural languages, making it easier to translate English written requirements into code that reads the same.</para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <screen>Assert.That(myobject, Is.True);
Assert.That(myobject, Is.EqualTo("bar"));
Assert.That(myobject, Is.Null.Or.EqualTo("foo"));</screen>
        <para>Instead of:</para>
        <screen>Assert.IsTrue(myobject);
Assert.IsEqual("bar", myobject);</screen>
        <para>
          <emphasis role="bold">Rationale</emphasis>:</para>
        <para>The constraint model works from left to right (where the classical model is from right to left), making it easier to write the assertions in code (you might not immediately remember the name of the variable your testing, but know what it should be, the left to right allows you to keep your train of thought).</para>
        <para>
          <emphasis role="bold">Rationale</emphasis>:</para>
        <para>The constraint model is much more powerful, implementing "or" and "and" conditions easily within an assertion, as in the third example. Doing the equivalent in the classical model is much more complicated.</para>
        <para>The sections following are examples only. The NUnit documentation should be followed, along with taking notes of warnings and messages for obsolescence as required.</para>
        <section>
          <title>Assert.That over Assert.Pass and Assert.Fail</title>
          <para>
            <superscript>
              <emphasis>Requirement: CREQ0202; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 11:21:49Z; Modified: 2019-11-02 15:34:59Z.</emphasis>
            </superscript>
          </para>
          <para>Avoid where ever possible the usage of <emphasis role="bold">Assert.Pass()</emphasis> and <emphasis role="bold">Assert.Fail()</emphasis> if it can be rewritten using <emphasis role="bold">Assert.That</emphasis>.</para>
          <para>
            <emphasis role="bold">Example</emphasis>:</para>
          <screen>Assert.That(bytesRead, Is.EqualTo(10), "Incorrect number of bytes");</screen>
          <para>Do not use</para>
          <screen>if (bytesRead != 10) Assert.Fail("Incorrect number of bytes");</screen>
        </section>
        <section>
          <title>Equality</title>
          <para>
            <superscript>
              <emphasis>Requirement: CREQ0194; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 10:50:39Z; Modified: 2019-11-02 12:57:24Z.</emphasis>
            </superscript>
          </para>
          <para>Test for equality with <emphasis role="bold">Is[.Not].EqualTo()</emphasis></para>
          <para>
            <emphasis role="bold">Example</emphasis>:</para>
          <screen>Assert.That(value, Is.EqualTo(expectedValue));
Assert.That(value, Is.Not.EqualTo(wrongValue));</screen>
          <para>Do not use</para>
          <screen>Assert.AreEqual(expectedValue, value);
Assert.AreNotEqual(wrongValue, value);</screen>
          <para>
            <emphasis role="bold">Note</emphasis>:</para>
          <para>The method <emphasis role="bold">AreEqual()</emphasis> in NUnit 2.6.x will perform implicit type conversion, where as the Constraint checks will fail if the types differ. e.g.</para>
          <screen>int value = 49;
Assert.AreEqual('1', value); // Pass
Assert.That(value, Is.EqualTo('1')); //Fail as char and int differ.</screen>
          <para>You will need to perform necessary type casts in code.</para>
        </section>
        <section>
          <title>Value Type Ranges</title>
          <para>
            <superscript>
              <emphasis>Requirement: CREQ0201; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 11:20:25Z; Modified: 2019-11-02 12:57:30Z.</emphasis>
            </superscript>
          </para>
          <para>Check that value types are within a range with <emphasis role="bold">Is.InRange(min, max)</emphasis></para>
          <para>
            <emphasis role="bold">Example</emphasis>:</para>
          <screen>Assert.That(myInt, Is.InRange(0, 5));</screen>
          <para>Do not use</para>
          <screen>Assert.That(myInt &gt;= 0 &amp;&amp; myInt &lt;6, Is.True);</screen>
        </section>
        <section>
          <title>Null Checks</title>
          <para>
            <superscript>
              <emphasis>Requirement: CREQ0195; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 10:53:31Z; Modified: 2019-11-02 12:57:33Z.</emphasis>
            </superscript>
          </para>
          <para>Test for null checks with <emphasis role="bold">Is[.Not].Null</emphasis></para>
          <para>
            <emphasis role="bold">Example</emphasis>:</para>
          <screen>Assert.That(myString, Is.Not.Null);
Assert.That(myString2, Is.Null);</screen>
          <para>Do not use</para>
          <screen>Assert.IsNotNull(myString);
Assert.NotNull(myString);
Assert.IsNull(myString2);
Assert.Null(myString2);</screen>
        </section>
        <section>
          <title>True/False Checks</title>
          <para>
            <superscript>
              <emphasis>Requirement: CREQ0196; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 10:54:57Z; Modified: 2019-11-02 12:57:40Z.</emphasis>
            </superscript>
          </para>
          <para>Test for true/false checks with <emphasis role="bold">Is.True</emphasis> or <emphasis role="bold">Is.False</emphasis></para>
          <para>
            <emphasis role="bold">Example</emphasis>:</para>
          <screen>Assert.That(value, Is.True);
Assert.That(value2, Is.False);</screen>
          <para>Do not use</para>
          <screen>Assert.IsTrue(value);
Assert.That(value);
Assert.IsFalse(value2);
Assert.That(!value2);</screen>
        </section>
        <section>
          <title>Type Comparisons</title>
          <para>
            <superscript>
              <emphasis>Requirement: CREQ0200; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 11:18:33Z; Modified: 2019-11-02 12:57:46Z.</emphasis>
            </superscript>
          </para>
          <para>Test for the object type with <emphasis role="bold">Is.TypeOf&lt;T&gt;()</emphasis> or <emphasis role="bold">Is.InstanceOf&lt;T&gt;()</emphasis></para>
          <para>
            <emphasis role="bold">Example</emphasis>:</para>
          <screen>Assert.That(myLine, Is.TypeOf&lt;TraceLineDlt&gt;());
Assert.That(myLine, Is.InstanceOf&lt;TraceLineDltBase&gt;());</screen>
          <para>Do not use</para>
          <screen>Assert.That(myLine is TraceLineDltBase, Is.True);
Assert.That(myLine.GetType() == typeof(TraceLineDlt), Is.True);</screen>
        </section>
        <section>
          <title>String Comparisons</title>
          <para>
            <superscript>
              <emphasis>Requirement: CREQ0197; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 10:57:58Z; Modified: 2019-11-02 11:18:28Z.</emphasis>
            </superscript>
          </para>
          <para>
            <emphasis role="bold">Example - String Equality</emphasis>:</para>
          <screen>Assert.That(myString, Is.EqualTo("string"));</screen>
          <para>Do not use</para>
          <screen>Assert.That(myString.Equals("string"), Is.True);</screen>
          <para>
            <emphasis role="bold">Example - StartsWith</emphasis>:</para>
          <screen>Assert.That(myString, Does.StartWith("str"));</screen>
          <para>Do not use</para>
          <screen>Assert.That(myString.StartsWith("str"), Is.True);</screen>
          <para>
            <emphasis role="bold">Example - EndsWith</emphasis>:</para>
          <screen>Assert.That(myString, Does.EndWith("ing"));</screen>
          <para>Do not use</para>
          <screen>Assert.That(myString.EndsWith("ing"), Is.True);</screen>
          <para>
            <emphasis role="bold">Example - Substrings</emphasis>:</para>
          <screen>Assert.That(myString, Contains.SubString("rin"));</screen>
          <para>
            <emphasis role="bold">Example - Regular Expressions</emphasis>:</para>
          <screen>Assert.That(myString, Is.StringMatching("s.*g"));</screen>
          <para>
            <emphasis role="bold">Example - String Length</emphasis>:</para>
          <screen>Assert.That(myString, Has.Length.EqualTo(5));</screen>
          <para>
            <emphasis role="bold">Example - Compound Check with RegEx</emphasis>:</para>
          <screen>Assert.That(myString, Has.Length.GreaterThan(2).And.Not.Matches(".*s$"));</screen>
        </section>
        <section>
          <title>Testing Exceptions</title>
          <para>
            <superscript>
              <emphasis>Requirement: CREQ0198; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 11:08:18Z; Modified: 2019-11-02 12:58:06Z.</emphasis>
            </superscript>
          </para>
          <para>Testing exceptions is made much simpler with the C# language construct lambdas.</para>
          <para>
            <emphasis role="bold">Example - Testing ArgumentNullException</emphasis>:</para>
          <screen>Assert.That(() =&gt; {
  myFunction(null);
}, Throws.TypeOf&lt;ArgumentNullException&gt;());</screen>
          <para>Note, that one should not use:</para>
          <screen>Throws.InstanceOf&lt;ArgumentException&gt;();</screen>
          <para>as the test would pass with the <emphasis role="bold">ArgumentException </emphasis>and all other exceptions derived thereof, not allowing test cases to properly test the API documentation for the method.</para>
          <para>Do not use the attribute</para>
          <screen>[ExpectedException(ArgumentNullException)]</screen>
          <para>Should the exception be thrown, it applies to the entire test case. If there is an error in the test case set up, the test might pass without the implementor realizing the test case is effectively doing nothing (without analyzing code coverage results in detail).</para>
          <para>
            <emphasis role="bold">Example - Test No Exception is Thrown</emphasis>:</para>
          <screen>Assert.That(() =&gt; {
  myFunction(string.Empty);
}, Throws.Nothing);</screen>
          <para>While an exception would fail without the assertion, it may improve the readability depending on the test case.</para>
        </section>
        <section>
          <title>Collection Asserts</title>
          <para>
            <superscript>
              <emphasis>Requirement: CREQ0193; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 10:43:07Z; Modified: 2019-11-02 10:50:21Z.</emphasis>
            </superscript>
          </para>
          <para>Use the following to test for equality of collections</para>
          <para>
            <emphasis role="bold">Example</emphasis>:</para>
          <screen>IList&lt;string&gt; output = Class.GetList();</screen>
          <para>
            <emphasis role="bold">Example - List Equality</emphasis>:</para>
          <screen>string[] expectedOutput = new[] { "string1", "string2" };
Assert.That(output, Is.EqualTo(expectedOutput));</screen>
          <para>Do not use:</para>
          <screen>CollectionAssert.AreEqual(expectedOutput, output);</screen>
          <para>
            <emphasis role="bold">Example - Membership</emphasis>:</para>
          <para>Assert.That(output, Has.Member("string1"))</para>
          <para>Do not use</para>
          <screen>Assert.That(output.Contains("string1"), Is.True);</screen>
          <para>
            <emphasis role="bold">Example - Two Lists by Reference</emphasis>:</para>
          <para>If the list references must be compared, not the content, you need to use different assertions:</para>
          <screen>Assert.That(output, Is.SameAs(originalList));</screen>
          <para>Do not use</para>
          <screen>Assert.That(ReferenceEquals(output, originalList), Is.True);</screen>
          <para>
            <emphasis role="bold">Example - Empty List</emphasis>:</para>
          <para>If the list is expected to be empty</para>
          <screen>Assert.That(output, Is.Empty);</screen>
          <para>Do not use</para>
          <screen>Assert.That(output.Count, Is.EqualTo(0));</screen>
        </section>
        <section>
          <title>TestCaseSource</title>
          <para>
            <superscript>
              <emphasis>Requirement: CREQ0199; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 11:15:24Z; Modified: 2019-11-02 11:17:46Z.</emphasis>
            </superscript>
          </para>
          <para>For test cases that have complex types of inputs, which can be reused across multiple test cases, the attribute</para>
          <screen>[TestCaseSource(source)]</screen>
          <para>can be used.</para>
          <para>The <emphasis role="bold">source </emphasis>parameter is the name of the function which provides the source test data.</para>
          <para>Use the <emphasis role="bold">nameof()</emphasis> operator instead of a string to provide the name of the function.</para>
          <para>The method providing the source must be <emphasis role="bold">static</emphasis>, to be compatible with NUnit 2 and NUnit 3. Do not use non-static methods for providing source data.</para>
        </section>
      </section>
      <section>
        <title>Test Cases</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0108; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:56:01Z; Modified: 2019-11-02 12:58:42Z.</emphasis>
          </superscript>
        </para>
        <para>In NUnit, you should use the <emphasis role="bold">[TestCase]</emphasis> attribute where it makes sense to improve test case coverage, without having to repeat significant portions of code.</para>
        <para>You should limit the maximum number of parameters to 3, to reduce the complexity of the test cases and the code.</para>
        <para>
          <emphasis role="bold">Rationale</emphasis>:</para>
        <para>It gets difficult when the number of <emphasis role="bold">[TestCase]</emphasis> attributes exceed 8. Still, there is no concrete requirement to limit the number of Test Cases, especially with string type inputs where the number of input variations can be high.</para>
      </section>
      <section>
        <title>Testing Complex Variations</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0109; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-17 08:57:00Z; Modified: 2019-11-02 12:58:46Z.</emphasis>
          </superscript>
        </para>
        <para>If you have more than three operational parameters that you want to test, then instead of using the <emphasis role="bold">[TestCase]</emphasis> attribute, you should design a test class and manually program testing the various combinations.</para>
      </section>
    </section>
  </section>
  <section>
    <title>Accessor Framework and Internal Classes</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0152; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Status: Proposed; Version: 1.0; Created: 2017-12-26 16:03:13Z; Modified: 2017-12-26 16:05:29Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>InternalsVisibleTo</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0154; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Stereotype: Functional; Status: Proposed; Version: 1.0; Created: 2017-12-26 16:05:30Z; Modified: 2019-11-02 12:58:54Z.</emphasis>
        </superscript>
      </para>
      <para>Do not use the <emphasis role="bold">InternalsVisibleTo </emphasis>attribute to allow testability of internal objects.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>The <emphasis role="bold">InternalsVisibleTo </emphasis>attribute is a powerful and convenient mechanism to implement a test case. Having production code refer to test code however, is unnatural (the test code should refer to production code it tests). It also implies directly a change to the assembly being tested if multiple assemblies for test would be desired and causes issues with strongly named binaries (also introducing reversed dependencies and increased build complexity).</para>
    </section>
    <section>
      <title>AccessorBase</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0153; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Status: Proposed; Version: 1.0; Created: 2017-12-26 16:03:28Z; Modified: 2019-11-02 12:59:06Z.</emphasis>
        </superscript>
      </para>
      <para>The NUnitExtensions <emphasis role="bold">AccessorBase </emphasis>implementation should be used for testing internal classes to an Assembly.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>An internal class is available for use for all components within an assembly, even if not generally available for other frameworks. It should contain sufficient test cases and have their public methods and properties tested as if it were a public class.</para>
      <para>
        <emphasis role="bold">Note</emphasis>:</para>
      <para>Not all features can be tested using the <emphasis role="bold">AccessorBase</emphasis>. Features that can be tested are:</para>
      <itemizedlist>
        <listitem>
          <para>Static and non-static types with static and non-static methods and properties;</para>
        </listitem>
        <listitem>
          <para>Nested classes, be they static or non-static;</para>
        </listitem>
        <listitem>
          <para>Private types returned by methods in other private types;</para>
        </listitem>
        <listitem>
          <para>Private types used in the signature of methods in other private types;</para>
        </listitem>
        <listitem>
          <para>Generics where the type parameters are public;</para>
        </listitem>
        <listitem>
          <para>Private types derived from other private types.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section>
      <title>Internal and Private Members</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0155; Author: Jason Curl &lt;jason.curl@harman.com&gt;; Status: Proposed; Version: 1.0; Created: 2017-12-26 16:10:45Z; Modified: 2019-11-02 12:59:58Z.</emphasis>
        </superscript>
      </para>
      <para>Unit test cases of internal types should restrict themselves to only testing <emphasis role="bold">public</emphasis>/<emphasis role="bold">internal</emphasis> members.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>If a test cases needs to test <emphasis role="bold">private </emphasis>members, this is an indication of a design problem. Consider other alternatives such as dependency injection and <emphasis role="bold">abstract class</emphasis>es or <emphasis role="bold">interface</emphasis>s.</para>
      <para>
        <emphasis role="bold">Example</emphasis>:</para>
      <para>A class <emphasis role="bold">ClassClient </emphasis>takes in its constructor an object of type <emphasis role="bold">ClassServer</emphasis> which contains a <emphasis role="bold">Register </emphasis>method. Instead of trying to test the <emphasis role="bold">private </emphasis>members of <emphasis role="bold">ClassServer </emphasis>that registration occurred, a test case should instead consider making for <emphasis role="bold">ClassServer </emphasis>also <emphasis role="bold">IClassServer </emphasis>so that the test case can implement its own <emphasis role="bold">Register </emphasis>method without needing to test the specific implementation of <emphasis role="bold">ClassServer</emphasis></para>
      <para>The original code might have been:</para>
      <screen>internal class ClassClient {
  public ClassClient(ClassServer server) {
    server.Register(this);
  }
}</screen>
      <para>This means that an instance of <emphasis role="bold">ClassServer </emphasis>needs to be created and somehow tested that <emphasis role="bold">ClassClient </emphasis>called Register. An alternative would be to use interfaces:</para>
      <screen>internal class ClassClient {
  public ClassClient(IClassServer server) {
    server.Register(this);
  }
}</screen>
      <para>with the small difference being now that the test code can implement the contract specified by <emphasis role="bold">IClassServer </emphasis>and can easily maintain itself that Register was called without having to resort to reflection or complicated test code.</para>
    </section>
  </section>
  <section>
    <title>Debug and Conditional Checks</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0177; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-06-29 22:51:27Z; Modified: 2019-11-04 19:53:24Z.</emphasis>
      </superscript>
    </para>
    <para>Sometimes it is necessary to perform checks in code, but disable them for release mode for performance reasons. Debug mode should perform extra checking that ensures consistency within the program (such as a "checked" build).</para>
    <section>
      <title>Debug.Assert</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0178; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-06-29 22:52:31Z; Modified: 2019-11-02 13:00:13Z.</emphasis>
        </superscript>
      </para>
      <para>Do <emphasis role="bold">not </emphasis>use <emphasis role="bold">Debug.Assert</emphasis>.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>Using <emphasis role="bold">Debug.Assert</emphasis> will raise a window to the user for extra debug information by default. This results in tests that can't be automated if a <emphasis role="bold">Debug.Assert</emphasis> fires, because the program will generally halt waiting for the user to continue.</para>
    </section>
    <section>
      <title>Contracts</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0179; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-06-29 22:53:44Z; Modified: 2019-11-02 10:35:09Z.</emphasis>
        </superscript>
      </para>
      <para>If the project build system supports contracts, then contracts should be used.</para>
      <para>Contracts allow internal and private methods to state assumptions, such as methods will not be called with null values. Debug mode can throw exceptions if a contract is violated (so that unit tests may find issues faster, rather than ignoring the problem), and static analysis tools may highlight code paths were contracts may be violated.</para>
      <para>THe advantage is that code states specifically what is intended and the checks are removed in release mode to allow for better performance.</para>
      <para>Microsoft contracts needs specific set up and tools for binary rewriting in release mode.</para>
      <para>Unit tests should therefore run in both release mode and debug mode (with and without contracts enabled).</para>
    </section>
  </section>
</chapter>
<chapter>
  <title>Visual Studio Extensions</title>
  <para>
    <superscript>
      <emphasis>Requirement: CREQ0110; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 08:01:10Z; Modified: 2019-11-02 11:24:35Z.</emphasis>
    </superscript>
  </para>
  <para>Code quality scan tools should be used during the development. For each tool, some common conditions are highlighted that should not occur.</para>
  <section>
    <title>Spell Checker (High)</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0111; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-06-13 09:35:06Z; Modified: 2016-07-25 20:53:26Z.</emphasis>
      </superscript>
    </para>
    <para>The Spell Checker Plugin from E. Woodruff should be used with the English-US or English-UK dictionary. It should be consistent throughout the project.</para>
    <para>These checks for spelling errors in XML comments, strings presented to the user and naming of variables.</para>
  </section>
  <section>
    <title>GhostDoc (Commercial, Mid)</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0112; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-06-13 09:37:03Z; Modified: 2019-11-02 11:25:15Z.</emphasis>
      </superscript>
    </para>
    <para>GhostDoc makes it considerably simpler to write comments for API methods with (Ctrl-Shift-D).</para>
    <para>As code may be moved to a framework component at any time, it is important the API documentation is correct and understandable.</para>
    <para>Most recent versions however require a license.</para>
  </section>
  <section>
    <title>ReSharper (Commercial, Low)</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0113; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-06-13 09:39:28Z; Modified: 2015-11-10 08:03:24Z.</emphasis>
      </superscript>
    </para>
    <para>ReSharper is a commercial tool and provides lint like functionality. Useful from ReSharper is the documentation explaining the reasoning for errors found.</para>
    <para>It can find typical coding design issues (usage of virtual methods in a constructor) as well as recommendations that can make code more readable.</para>
  </section>
  <section>
    <title>Concurrency Analysis (Mid)</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0119; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-10-20 21:48:34Z; Modified: 2019-11-02 13:00:42Z.</emphasis>
      </superscript>
    </para>
    <para>In use cases where performance is required on multithreaded systems, the Microsoft concurrency plugins shall be used for analyzing thread and CPU core usage.</para>
  </section>
</chapter>
<chapter>
  <title>Visual Studio Analyzers</title>
  <para>
    <superscript>
      <emphasis>Requirement: CREQ0203; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 11:24:42Z; Modified: 2019-11-02 11:24:47Z.</emphasis>
    </superscript>
  </para>
  <section>
    <title>Difference between VSIX and NuGet Analyzers</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0237; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 13:04:11Z; Modified: 2019-11-02 13:06:05Z.</emphasis>
      </superscript>
    </para>
    <para>Use a VSIX analyzer in your solution if the warnings and messages should be available while developing. VSIX analyzers do not affect the build in any way.</para>
    <para>Use a NuGet analyzer as part of your project if such rules should be made where warnings and errors can abort the build process (enforcing rules during the build). This is a much stricter model. There is no way to enable NuGet analyzers for all projects in a .NET Desktop solution.</para>
  </section>
  <section>
    <title>Suppression of Rules</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0306; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 18:13:18Z; Modified: 2019-11-02 18:13:24Z.</emphasis>
      </superscript>
    </para>
    <section>
      <title>Pragma Usage</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0311; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 18:24:31Z; Modified: 2019-11-02 18:25:47Z.</emphasis>
        </superscript>
      </para>
      <para>Pragmas should not be used for disabling warnings, unless there is no other way.</para>
      <para>Where possible, suppress warnings through attributes.</para>
      <para>
        <emphasis role="bold">Rationale</emphasis>:</para>
      <para>It is easy to write tools to parse through assemblies using reflection to find attributes, even for binaries. Pragma's only exist at the source level.</para>
    </section>
    <section>
      <title>VSIX Global Suppression</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0307; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 18:13:31Z; Modified: 2019-11-02 18:15:32Z.</emphasis>
        </superscript>
      </para>
      <para>Each project shall have its own <emphasis role="bold">GlobalSuppression.cs</emphasis> file, which will be used to maintain a list of suppressions.</para>
      <para>This file can be automatically generated by Visual Studio when suppressing a warning or a message in a file. The suppression attribute shall be modified so that:</para>
      <itemizedlist>
        <listitem>
          <para>The <emphasis role="bold">Target </emphasis>property is removed</para>
        </listitem>
        <listitem>
          <para>The <emphasis role="bold">Member </emphasis>property is removed</para>
        </listitem>
        <listitem>
          <para>The <emphasis role="bold">Justification </emphasis>property is updated.</para>
        </listitem>
      </itemizedlist>
      <para>There is no way in .NET FX to enable suppression for all projects.</para>
    </section>
    <section>
      <title>NuGet Global Suppression</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0309; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 18:16:56Z; Modified: 2019-11-02 18:17:28Z.</emphasis>
        </superscript>
      </para>
      <para>Should an analyzer be provided in a project, the suppression of rules shall be done using the project ruleset.</para>
    </section>
    <section>
      <title>Suppression in Source</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0308; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Stereotype: Functional; Status: Proposed; Version: 1.0; Created: 2019-11-02 18:15:43Z; Modified: 2022-06-29 21:41:01Z.</emphasis>
        </superscript>
      </para>
      <para>The suppression attribute may be applied to a member or a <emphasis role="bold">class</emphasis>.</para>
      <itemizedlist>
        <listitem>
          <para>The <emphasis role="bold">Justification </emphasis>property shall be provided</para>
        </listitem>
        <listitem>
          <para>The <emphasis role="bold">Member </emphasis>and <emphasis role="bold">Target </emphasis>properties are by default not provided.</para>
        </listitem>
      </itemizedlist>
      <para>A suppression can be applied to a class for multiple members, but the suppression should be as concise as possible (i.e. at the most specific member, with the smallest scope). Thus, when applied to a <emphasis role="bold">class</emphasis>, it may be required to provide the <emphasis role="bold">Member </emphasis>property for a suppression. An example of this is S4136, adjacent methods, where the suppression would need to apply for all overloads of a member.</para>
      <para>
        <emphasis role="bold">Example, Member Suppression on a Class</emphasis>:</para>
      <screen>[System.Diagnostics.CodeAnalysis.SuppressMessage("Minor Code Smell", "S4136:Method overloads should be grouped together",
    Justification = "Code organized by functional group (byte/char)",
    Scope = "member", Target = "~M:RJCP.Diagnostic.ConsoleReader.Read")]
public class ConsoleReader : Stream</screen>
      <para>When applied to the class, all the <emphasis role="bold">Read </emphasis>methods are suppressed, but the <emphasis role="bold">Write </emphasis>methods are not.</para>
    </section>
    <section>
      <title>Suppression with .editorconfig</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0312; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-03 12:19:59Z; Modified: 2019-11-06 19:29:29Z.</emphasis>
        </superscript>
      </para>
      <para>New in Visual Studio 2019 16.3 is the ability to suppress error messages in the IDE via the <emphasis role="bold">.editorconfig</emphasis> file. This should be avoided.</para>
      <para>Even though this is a central location for the suppression of rules, it applies to the editor only, not the build system.</para>
    </section>
    <section>
      <title>False Positives</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0310; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 18:22:37Z; Modified: 2019-11-06 19:29:23Z.</emphasis>
        </superscript>
      </para>
      <para>False positives should generally not be suppressed, so that fixes in the analyzer can be found. For example, SonarLint 4.12 has false positives for the usage of <emphasis role="bold">null </emphasis>parameters, that were fixed in 4.13 which shows more likely errors.</para>
      <para>For cases where it must be suppressed, the Justification should contain the test "False Positive, reason" and be applied at the scope where the false positive has minimal effect.</para>
    </section>
  </section>
  <section>
    <title>SonarLint for Visual Studio (High)</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0125; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2016-07-25 21:01:59Z; Modified: 2019-11-02 13:04:05Z.</emphasis>
      </superscript>
    </para>
    <para>Sonar Lint for Visual Studio (as of writing version 4.13) should be used in projects. It is an Open Source tool with support by Microsoft, working with Visual Studio 2017 and later.</para>
    <para>SonarLint should be installed as a Visual Studio extension, not as a NuGet package for individual projects.</para>
    <section>
      <title>Rules which should not be ignored</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0241; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 13:33:39Z; Modified: 2019-11-02 13:33:43Z.</emphasis>
        </superscript>
      </para>
      <section>
        <title>S108: Either remove or fill this block of code</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0242; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 13:33:52Z; Modified: 2019-11-02 13:43:16Z.</emphasis>
          </superscript>
        </para>
        <para>Do not have empty statements, this indicates a probable typing error. Fix the problem by removing it, making a comment why it should be empty, or provide actual code.</para>
        <screen>while (true) { }</screen>
        <para>Make a comment as such:</para>
        <screen>while (true) { /* infinite loop */ }</screen>
        <para>A second common issue is catching and ignoring exceptions</para>
        <screen>try {
  DoSomething();
} catch {
} finally {
}</screen>
        <para>The catch block will catch everything, and it's not obvious why. Catch blocks shouldn't catch everything.</para>
      </section>
      <section>
        <title>S907: Remove this use of goto</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0291; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:56:02Z; Modified: 2019-11-02 14:56:24Z.</emphasis>
          </superscript>
        </para>
        <para>For all those who remember spaghetti code and the 1980's</para>
      </section>
      <section>
        <title>S927: Rename parameter to match interface declaration</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0292; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:56:35Z; Modified: 2019-11-02 14:58:21Z.</emphasis>
          </superscript>
        </para>
        <para>Methods defined in a class, should  have the same parameter names as the methods defined in the interface it is inheriting from</para>
        <para>
          <emphasis role="bold">Old</emphasis>:</para>
        <screen>interface MyInterface {
  void DoSomething(int a, int b);
}

public class MyClass : MyInterface {
  public void DoSomething(int b, int a);
}</screen>
        <para>
          <emphasis role="bold">New</emphasis>:</para>
        <screen>interface MyInterface {
  void DoSomething(int a, int b);
}

public class MyClass : MyInterface {
  public void DoSomething(int a, int b);
}</screen>
      </section>
      <section>
        <title>S1104: Make the field private and encapsulate it in a public property</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0243; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 13:38:05Z; Modified: 2019-11-06 19:28:49Z.</emphasis>
          </superscript>
        </para>
        <para>Do not make fields <emphasis role="bold">public</emphasis>.</para>
        <para>
          <emphasis role="bold">Old</emphasis>:</para>
        <screen>public struct TraceLineData {
  public ITraceLine TraceLine;

  public TraceLineData(ITraceLine line) {
    TraceLine = line;
  }
}</screen>
        <para>
          <emphasis role="bold">New</emphasis>:</para>
        <screen>public struct TraceLineData {
  public ITraceLine TraceLine { get; set; }

  public TraceLineData(ITraceLine line) {
    TraceLine = line;
  }
}</screen>
        <para>
          <emphasis role="bold">Rationale</emphasis>:</para>
        <para>It is not possible to modify the code without breaking the API if new checks need to be made when getting or setting the property (e.g. setting might raise an exception, getting might need a performance optimization and use lazy initialization).</para>
      </section>
      <section>
        <title>S1116: Remove this empty statement</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0244; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 13:41:28Z; Modified: 2019-11-06 19:28:40Z.</emphasis>
          </superscript>
        </para>
        <para>Do not have empty statements, this indicates a probable typing error. Fix the problem by removing it, making a comment why it should be empty, or provide actual code.</para>
        <para>An example of where this is important is an accidental semicolon <emphasis role="bold">;</emphasis> after <emphasis role="bold">while </emphasis>loop, that may make it an infinite loop (note the spacing, which a person might interpret as being part of the while loop, where in reality spacing is ignored by the compiler).</para>
        <screen>while (true);
  if (x == true) return;</screen>
        <para>The <emphasis role="bold">while </emphasis>loop will become an infinite loop. Of course, if one really did want an infinite loop, then make a comment as such:</para>
        <screen>while (true) { /* infinite loop */ }</screen>
      </section>
      <section>
        <title>S1118: Add a protected constructor or the static keyword to the class delcaration</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0245; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 13:43:31Z; Modified: 2019-11-06 19:28:17Z.</emphasis>
          </superscript>
        </para>
        <para>THis occurs when a <emphasis role="bold">class </emphasis>only has <emphasis role="bold">static </emphasis>methods.</para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <screen>public class NetInfo {
  public static string GetCurrentInterface() { ... }
}</screen>
        <para>Should be rewritten as</para>
        <screen>public static class NetInfo {
  public static string GetCurrentInterface() { ... }
}</screen>
      </section>
      <section>
        <title>S1125: Remove the unnecessary boolean literals</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0248; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 13:48:18Z; Modified: 2019-11-06 19:28:10Z.</emphasis>
          </superscript>
        </para>
        <para>Do not compare types which are boolean against <emphasis role="bold">true </emphasis>or <emphasis role="bold">false</emphasis>.</para>
        <para>
          <emphasis role="bold">Old</emphasis>:</para>
        <screen>bool value = false;
if (value == false) Console.WriteLine("false");</screen>
        <para>
          <emphasis role="bold">New</emphasis>:</para>
        <screen>bool value = false;
if (!value) Console.WriteLine("false");</screen>
      </section>
      <section>
        <title>S1135: Complete the task associated with the TODO comment</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0250; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 13:52:35Z; Modified: 2019-11-06 19:28:06Z.</emphasis>
          </superscript>
        </para>
        <para>Programmers add '<emphasis role="bold">TODO</emphasis>' indicating that functionality is not complete. These warnings should be present and visible to the user so they can be acted upon.</para>
      </section>
      <section>
        <title>S1172: Remove this unused method parameter</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0252; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 13:54:27Z; Modified: 2019-11-02 13:56:02Z.</emphasis>
          </superscript>
        </para>
        <para>The method signature contains a parameter which is unused and the object is not publicly accessible.</para>
        <para>
          <emphasis role="bold">Rationale</emphasis>:</para>
        <para>Should remove unused parameters, as each parameter is pushed on to the stack. Performance code may be slightly impacted by this.</para>
        <para>On the other hand, if the code is not impacted by performance, one may want to ignore this warning stating that methods follow a particular syntax.</para>
      </section>
      <section>
        <title>S1206: Class overrides GetHashCode and should override Equals</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0253; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 13:56:16Z; Modified: 2019-11-02 13:58:18Z.</emphasis>
          </superscript>
        </para>
        <para>When providing an implementation of <emphasis role="bold">Equals</emphasis>, one must always provide an implementation of the <emphasis role="bold">GetHashCode </emphasis>method.</para>
        <para>The <emphasis role="bold">GetHashCode </emphasis>method is used by .NET framework datastructures, such as <emphasis role="bold">Dictionary </emphasis>and <emphasis role="bold">HashSet </emphasis>for sorting values.</para>
        <para>Users would expect that if two objects are equal, then their hash code are also equal.</para>
        <para>
          <emphasis role="bold">Note</emphasis>:</para>
        <para>The reverse is not true, if two hash codes are equal, the objects are not necessarily equal.</para>
      </section>
      <section>
        <title>S1481: Remove the unused local variable</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0255; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:00:06Z; Modified: 2019-11-02 14:03:07Z.</emphasis>
          </superscript>
        </para>
        <para>If the local variable is not used, it should be removed. This may indicate code paths that are not executed, showing errors. Compilers may optimize code so that the paths relying on this variable are removed.</para>
        <para>Use the discard variable _, to indicate that the variable isn't needed</para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <screen>Assert.That(() =&gt; {_ = new MyObject(null); }, Throws.TypeOf&lt;ArgumentNullException&gt;());</screen>
        <para>This example makes it clear that we're looking for an exception in test code and do not care about the object instantiated if the test should fail.</para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <screen>if (!dict.Search("input", out _, out int count)) { ... }</screen>
        <para>This example indicates that only the second out parameter is required.</para>
      </section>
      <section>
        <title>S1854: Remove useless assignment to local variable</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0256; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:03:38Z; Modified: 2019-11-02 14:04:35Z.</emphasis>
          </superscript>
        </para>
        <para>See also IDE0052 and IDE0059.</para>
      </section>
      <section>
        <title>S1871: Merge this branch or change one of the implementations</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0257; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:04:49Z; Modified: 2019-11-02 14:05:57Z.</emphasis>
          </superscript>
        </para>
        <para>Indicates often a copy/paste bug. Either an <emphasis role="bold">else</emphasis>/<emphasis role="bold">if</emphasis> block or a switch case has identical implementations.</para>
        <para>They should be merged, or corrected (if it was a copy/paste bug).</para>
      </section>
      <section>
        <title>S1905: Remove unnecessary cast</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0258; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:06:17Z; Modified: 2019-11-04 19:53:08Z.</emphasis>
          </superscript>
        </para>
        <para>There's a cast to an object that is not required. Remove the cast.</para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <screen>protected static int Reflect(int value, int bits) { ... }

if (m_RefIn ^ m_RefOut) crc = (int)Reflect(crc, 32);</screen>
        <para>This might indicate a coding error.</para>
      </section>
      <section>
        <title>S2259: Variable is null on at least one execution path</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0260; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:09:30Z; Modified: 2019-11-02 14:10:02Z.</emphasis>
          </superscript>
        </para>
        <para>This is a probable bug, that could lead to a <emphasis role="bold">NullReferenceException</emphasis>. It should be analyzed and fixed.</para>
      </section>
      <section>
        <title>S2292: Make this an auto-implemented property</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0261; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:10:14Z; Modified: 2019-11-02 14:11:34Z.</emphasis>
          </superscript>
        </para>
        <para>Reduce the amount of code, and reduce possible errors during initialization by using auto-properties.</para>
        <para>
          <emphasis role="bold">Old</emphasis>:</para>
        <screen>private int m_Value = 42;
public int Value {
  get { return m_Value; }
  set { m_Value = value; }
}</screen>
        <para>
          <emphasis role="bold">New</emphasis>:</para>
        <screen>public int Value { get; set; } = 42;</screen>
      </section>
      <section>
        <title>S2328: Refactor GetHashCode to not reference mutable fields</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0262; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:11:48Z; Modified: 2019-11-02 14:13:25Z.</emphasis>
          </superscript>
        </para>
        <para>.NET implementations such as <emphasis role="bold">Dictionary </emphasis>and <emphasis role="bold">HashSet </emphasis>use the <emphasis role="bold">GetHashCode </emphasis>function when sorting and inserting the object into their data structure. If the <emphasis role="bold">GetHashCode </emphasis>were mutable, this would cause errors in those data structures (the objects might not be found, sorting breaks).</para>
        <para>To fix this, parameters within <emphasis role="bold">GetHashCode </emphasis>should reference <emphasis role="bold">readonly </emphasis>properties only.</para>
      </section>
      <section>
        <title>S2347: Remove this silly bit operation</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0263; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:13:55Z; Modified: 2019-11-02 14:14:21Z.</emphasis>
          </superscript>
        </para>
        <para>This indicates dead code and should be removed</para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <screen>typeInfo |= 0x00;</screen>
      </section>
      <section>
        <title>S2486: Handle the exception or explain why it can be ignored</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0264; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:14:33Z; Modified: 2019-11-02 14:16:29Z.</emphasis>
          </superscript>
        </para>
        <para>MSDN rules state that general catch all's should not be used. Some exceptions are not catchable regardless of a try/catch operation (e.g. such as memory corruption, unless overridden in the applications configuration file).</para>
        <para>Fix by catching only those exceptions expected and implement proper unit tests.</para>
        <para>Workaround the problem by providing a comment in the block why it can be ignored.</para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <screen>try {
  lock (m_SocketLock) {
    // Indicate that we want to close the socket and end (no retries)
    m_SocketClosed.Set();
    if (m_SocketReader != null) m_SocketReader.Close();
    if (m_Socket != null) m_Socket.Close();
  }
} catch { }</screen>
      </section>
      <section>
        <title>S2583: Change condition so that it does not always evaluate to false; some subsequent code is never executed</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0265; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:16:37Z; Modified: 2019-11-06 19:27:35Z.</emphasis>
          </superscript>
        </para>
        <para>SonarLint has detected that a variable check is always false, so that an if block is never entered. This indicates a bug by having dead code.</para>
        <para>
          <emphasis role="bold">Warning</emphasis>:</para>
        <para>SonarLint 4.13 appears to have a false positive where it doesn't properly process try/catch blocks.</para>
        <screen>bool created = false;
int attempts = CopyWaitAttempts;
DeleteFile(fullPath);
do {
  try {
    Directory.CreateDirectory(fullPath);
    created = true;
  } catch (AccessViolationException) {
    if (attempts == 0) throw;
  } catch (UnauthorizedAccessException) {
    // On windows occurs if the file is already open.
    if (attempts == 0) throw;
  }
  
  if (!created) {
    // If the copy failed, it's because it's probably already open somewhere else. So we
    // wait 250ms and try again.
    --attempts;
    Thread.Sleep(CopyWaitInterval);
  }
} while (!created);</screen>
        <para>The bug is with the<emphasis role="bold"> if (!created)</emphasis>, clearly the analyzer did not see that <emphasis role="bold">created </emphasis>is set to <emphasis role="bold">false</emphasis>, and only set to <emphasis role="bold">true </emphasis>on success.</para>
      </section>
      <section>
        <title>S2589: Change condition so that it does not always evaluate to true</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0266; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:19:37Z; Modified: 2019-11-02 14:19:47Z.</emphasis>
          </superscript>
        </para>
      </section>
      <section>
        <title>S2737: Add logic to this catch clause or eliminate it and rethrow automatically</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0267; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Stereotype: Functional; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:21:11Z; Modified: 2019-11-04 19:52:43Z.</emphasis>
          </superscript>
        </para>
        <para>Should not have catch clauses that only rethrow exceptions</para>
        <para>
          <emphasis role="bold">Old</emphasis>:</para>
        <screen>try {
  DoSomething();
} catch {
  throw;
} finally {
  CleanUp();
}</screen>
        <para>
          <emphasis role="bold">New</emphasis>:</para>
        <screen>try {
  DoSomething();
} finally {
  CleanUp();
}</screen>
      </section>
      <section>
        <title>S3218: Rename this field to not shadow the outer class member</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0268; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:23:28Z; Modified: 2019-11-02 14:24:59Z.</emphasis>
          </superscript>
        </para>
        <para>A class outer class has defined a member variable, the inner class shadows this with a new declaration.</para>
        <para>Rename, so that maintainers don't get confused about which variable is being accessed.</para>
      </section>
      <section>
        <title>S3237: Use the value parameter in the event add/remove or property set declaration</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0269; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:25:32Z; Modified: 2019-11-02 14:26:20Z.</emphasis>
          </superscript>
        </para>
        <para>Not using the value means that the accessor ignores the caller's intent which could cause unexpected results at runtime.</para>
      </section>
      <section>
        <title>S3246: Add the 'in' keyword to make it contravariant</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0271; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:27:41Z; Modified: 2019-11-06 19:27:18Z.</emphasis>
          </superscript>
        </para>
        <para>In the interests of making code as usable as possible, interfaces and delegates with generic parameters should use the out and in modifiers when possible to make the interfaces and delegates covariant and contravariant, respectively.</para>
        <para>The <emphasis role="bold">out </emphasis>keyword can be used when the type parameter is used only as a return type in the <emphasis role="bold">interface </emphasis>or <emphasis role="bold">delegate</emphasis>. Doing so makes the parameter covariant, and allows <emphasis role="bold">interface </emphasis>and <emphasis role="bold">delegate </emphasis>instances created with a sub-type to be used as instances created with a base type. The most notable example of this is <emphasis role="bold">IEnumerable&lt;out T&gt;</emphasis>, which allows the assignment of an <emphasis role="bold">IEnumerable&lt;string&gt;</emphasis> instance to an <emphasis role="bold">IEnumerable&lt;object&gt;</emphasis> variable, for instance.</para>
        <para>The in keyword can be used when the type parameter is used only as a method parameter in the interface or a parameter in the delegate. Doing so makes the parameter contravariant, and allows interface and delegate instances created with a base type to be used as instances created with a sub-type. I.e. this is the inversion of covariance. The most notable example of this is the <emphasis role="bold">Action&lt;in T&gt;</emphasis> delegate, which allows the assignment of an <emphasis role="bold">Action&lt;object&gt;</emphasis> instance to a <emphasis role="bold">Action&lt;string&gt;</emphasis> variable, for instance.</para>
        <para>
          <emphasis role="bold">Old</emphasis>:</para>
        <screen>interface IConsumer&lt;T&gt; {  // Noncompliant
  bool Eat(T fruit);
}</screen>
        <para>
          <emphasis role="bold">New</emphasis>:</para>
        <screen>interface IConsumer&lt;in T&gt; {
  bool Eat(T fruit);
}</screen>
      </section>
      <section>
        <title>S3376: Make class name end with EventArgs</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0273; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:30:05Z; Modified: 2019-11-02 14:30:31Z.</emphasis>
          </superscript>
        </para>
        <para>Use standard naming conventions as prescribed by .NET</para>
      </section>
      <section>
        <title>S3415: Make sure arguments are in the correct order</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0274; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:30:50Z; Modified: 2019-11-02 14:32:21Z.</emphasis>
          </superscript>
        </para>
        <para>Assertions in test code is comparing a value/function call against a constant. The order should be</para>
        <screen>Assert.That(variable, Is.EqualTo(constant))
Assert.AreEqual(constant, variable)</screen>
        <para>This checks that calls are as MSTest, NUnit or XUnit expect.</para>
      </section>
      <section>
        <title>S3453: This class can't be instantiated, make it's constructor public</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0275; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:32:37Z; Modified: 2019-11-06 19:26:30Z.</emphasis>
          </superscript>
        </para>
        <para>A <emphasis role="bold">class </emphasis>is defined that it cannot be instantiated, so it is dead code.</para>
        <para>
          <emphasis role="bold">Warning</emphasis>:</para>
        <para>A valid case of this warning is defining classes derived from <emphasis role="bold">SafeHandle</emphasis>. The class is instantiated by the .NET marshaller, and the constructor is expected to be <emphasis role="bold">private</emphasis>.</para>
        <screen>internal sealed class SafeLibraryHandle : SafeHandle {
  private SafeLibraryHandle() : base(IntPtr.Zero, true) { }

  public override bool IsInvalid {
      get { return base.handle == IntPtr.Zero; }
  }

  protected override bool ReleaseHandle() {
      return UnsafeNativeMethods.FreeLibrary(base.handle);
  }
}</screen>
      </section>
      <section>
        <title>S3459: Remove unassigned autoproperty, or set its value</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0277; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:37:13Z; Modified: 2019-11-06 19:26:18Z.</emphasis>
          </superscript>
        </para>
        <para>A property which is private, or in a <emphasis role="bold">private class </emphasis>is defined, but never set. This could indicate a bug, or dead code.</para>
      </section>
      <section>
        <title>S3869: Refactor code to remove SafeHandle.DangerousGetHandle</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0278; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:38:02Z; Modified: 2019-11-06 19:26:12Z.</emphasis>
          </superscript>
        </para>
        <para>The usage of <emphasis role="bold">DangerousGetHandle </emphasis>is problematic as there is no reference counting or memory management. Should an exception occur at any time (including unexpected exceptions, such as aborting threads), handles might not be properly freed.</para>
        <para>There is also the possibility that the handle obtained is freed at any time by the object it was obtained from, thus resulting in crashes with Native code.</para>
        <para>This is a difficult topic, and should be avoided where ever possible.</para>
      </section>
      <section>
        <title>S3881: Fix implementation of IDIsposable to conform to the DIspose pattern</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0279; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:39:55Z; Modified: 2019-11-06 19:26:05Z.</emphasis>
          </superscript>
        </para>
        <para>Not properly implementing the <emphasis role="bold">Dispose</emphasis> pattern can result in memory or resource leaks and poor performing code.</para>
      </section>
      <section>
        <title>S3889: Remove use of Thread.Resume and Thread.Suspend</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0280; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:40:47Z; Modified: 2019-11-06 19:25:59Z.</emphasis>
          </superscript>
        </para>
        <para>Use other synchronization primitives, such as <emphasis role="bold">ManualResetEvent</emphasis>, etc. to properly control when threads are paused and resumed.</para>
        <para>These methods should never be used.</para>
      </section>
      <section>
        <title>S3925: Update implementation of ISerializable to conform to recommended pattern</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0281; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:41:49Z; Modified: 2019-11-06 19:25:57Z.</emphasis>
          </superscript>
        </para>
        <para>Typically occurs when implementing exceptions. The serialization interface patter should be properly implemented.</para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <screen>[Serializable]
public class MyException : Exception {
  public MyException() { }

  protected MyException(SerializationInfo info, StreamingContext context) {
    ...
  }

  public override void GetObjectData(SerializationInfo info, StreamingContext context) {
    ..
  }
}</screen>
      </section>
      <section>
        <title>S3928: Use a constructor overload that allows more meaningful exception error message</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0282; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:46:11Z; Modified: 2019-11-02 14:46:56Z.</emphasis>
          </superscript>
        </para>
        <para>Avoid raising exceptions like</para>
        <screen>throw new ArgumentException();</screen>
        <para>Instead</para>
        <screen>throw new ArgumentException("Input of wrong type");</screen>
      </section>
      <section>
        <title>S3966: Refactor to ensure code is only disposed once</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0283; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:47:06Z; Modified: 2019-11-02 14:47:37Z.</emphasis>
          </superscript>
        </para>
        <para>Do not dispose an object twice. This may lead to an <emphasis role="bold">ObjectDisposedException</emphasis>.</para>
      </section>
      <section>
        <title>S3971: Do not call GC.SuppressFinalize</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0284; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:47:49Z; Modified: 2019-11-02 14:48:14Z.</emphasis>
          </superscript>
        </para>
        <para>A call to <emphasis role="bold">GC.SuppressFinalize()</emphasis> should only occur in the Dispose method of an object.</para>
      </section>
      <section>
        <title>S4144: Update method that the implementation is not identical to another method</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0288; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:51:53Z; Modified: 2019-11-02 14:52:39Z.</emphasis>
          </superscript>
        </para>
        <para>This is often a copy/paste bug, and indicates unintended behavior.</para>
      </section>
      <section>
        <title>S4487: Remove unread private field</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0289; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:53:01Z; Modified: 2019-11-02 14:53:25Z.</emphasis>
          </superscript>
        </para>
        <para>See IDE0052</para>
      </section>
      <section>
        <title>S4583: Pair BeginInvoke with EndInvoke</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0290; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:53:33Z; Modified: 2019-11-06 19:25:48Z.</emphasis>
          </superscript>
        </para>
        <para>The objects should be paired, so that thread execution is synchronized and that there are no memory leaks.</para>
        <para>Alternatively, rewrite code to use threads instead;</para>
        <para>
          <emphasis role="bold">Old</emphasis>:</para>
        <screen>Action startServer = () =&gt; {
  Thread.Sleep(2000);
  gnLogServer.Listen(TestConfig.GnLogListenPort);
};
startServer.BeginInvoke(null, null);</screen>
        <para>
          <emphasis role="bold">New (preferred)</emphasis>:</para>
        <screen>Thread startServer = new Thread(() =&gt; {
  Thread.Sleep(2000);
  gnLogServer.Listen(TestConfig.GnLogListenPort);
});
startServer.Start();
Assert.That(startServer.Join(5000), Is.True);</screen>
      </section>
    </section>
    <section>
      <title>Aesthetic Rules which Should be Enabled</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0246; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 13:45:34Z; Modified: 2019-11-02 13:45:48Z.</emphasis>
        </superscript>
      </para>
      <section>
        <title>S125: Remove the commented out code</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0254; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 13:58:28Z; Modified: 2019-11-02 13:59:52Z.</emphasis>
          </superscript>
        </para>
        <para>Commented out code usually indicates a refactoring and the code is either outdated, or is a TODO element. One should remove it if it is no longer relevant, and rely on revision control systems to know what changed.</para>
        <para>
          <emphasis role="bold">Warning</emphasis>:</para>
        <para>SonarLint often marks this as a false positive if it sees some particular characters, such as <emphasis role="bold">;</emphasis>, and may need to be suppressed as needed.</para>
      </section>
      <section>
        <title>S1121: Extract the assignment from this expression</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0247; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 13:45:50Z; Modified: 2019-11-02 15:36:00Z.</emphasis>
          </superscript>
        </para>
        <para>SonarLint is warning that the expression is probably complicated and difficult to read</para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <screen>cbuf[--i] = (char)('0' | (v &gt;&gt;= 4) &amp; 0xf);</screen>
        <para>It's stating that the variable <emphasis role="bold">v</emphasis> should be extracted.</para>
        <para>It's up to the user, if readability is impacted or not. One reason to ignore this would be for code that is repetitive and repeated multiple times. Extracting this variable might increase the size of the code significantly making it larger than a screen, where what is important are the changes between each line.</para>
      </section>
      <section>
        <title>S1128: Remove this unnecessary using</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0249; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 13:49:50Z; Modified: 2019-11-06 19:25:36Z.</emphasis>
          </superscript>
        </para>
        <para>Remove using statements within the namespace which aren't referenced anywhere.</para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <screen>using System;
using System.Text;</screen>
        <para>There is no code using <emphasis role="bold">System.Text</emphasis>, so it should be removed.</para>
        <para>
          <emphasis role="bold">Warning</emphasis>:</para>
        <para>In SonarLint 4.13.0.11687 there are two bugs:</para>
        <itemizedlist>
          <listitem>
            <para>using System.Linq will be warned even if there is the usage of the select keyword. Removing this will break compilation.</para>
          </listitem>
          <listitem>
            <para>using &lt;namespace&gt; will be warned even if there is a MAML documentation statement referencing the namespace. Removing this will break documentation generation.</para>
          </listitem>
        </itemizedlist>
      </section>
      <section>
        <title>S1144: Remove the unused private field</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0251; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 13:53:45Z; Modified: 2019-11-02 13:53:56Z.</emphasis>
          </superscript>
        </para>
        <para>See IDE0051</para>
      </section>
      <section>
        <title>S1939: Interface implements another interface and so can be removed</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0259; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:07:54Z; Modified: 2019-11-06 19:25:28Z.</emphasis>
          </superscript>
        </para>
        <para>The .NET framework has interfaces that derive from other interfaces. It is only necessary to derive from one interface, not all of them.</para>
        <para>
          <emphasis role="bold">Old</emphasis>:</para>
        <screen>public class MyList : IList&lt;int&gt;, ICollection&lt;int&gt;, IEnumerable&lt;int&gt;</screen>
        <para>
          <emphasis role="bold">New (fix)</emphasis>:</para>
        <screen>public class MyList : IList&lt;int&gt;</screen>
      </section>
      <section>
        <title>S3241: Change return type to void, not a single caller uses the value</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0270; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:26:38Z; Modified: 2019-11-02 14:27:12Z.</emphasis>
          </superscript>
        </para>
        <para>Private methods are clearly intended for use only within their own scope. When such methods return values that are never used by any of their callers, then clearly there is no need to actually make the return, and it should be removed in the interests of efficiency and clarity.</para>
      </section>
      <section>
        <title>S3358: Extract this nested ternary operation</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0272; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:29:08Z; Modified: 2019-11-02 14:29:45Z.</emphasis>
          </superscript>
        </para>
        <para>SonarLint has determined that there are nested ternary operators. The readability of the code is made much more difficult because of this, and the intent of the code can be misunderstood.</para>
      </section>
      <section>
        <title>S3458: Remove this empty case clause</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0276; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:34:39Z; Modified: 2019-11-06 19:25:19Z.</emphasis>
          </superscript>
        </para>
        <para>SonarLint will indicate a warning if there is a case statement which is empty and it falls through to the default case.</para>
        <para>
          <emphasis role="bold">Example:</emphasis>
        </para>
        <screen>switch (subtype) {
case TraceSvr.RT_SCOPE_COUNT:
  GetScopeCount();
  break;
case TraceSvr.RT_PROCESS_COUNT:
case TraceSvr.RT_SERVER_VERSION:
default:
  overhead += packetLength;
}</screen>
        <para>It might be desirable to keep the case statements to show that specific cases are expected to be the same as the default case, so in a code review one can see if something might be missing or not.</para>
      </section>
      <section>
        <title>S3973: Use curly braces or indentation with if statements</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0285; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:48:49Z; Modified: 2019-11-02 14:49:08Z.</emphasis>
          </superscript>
        </para>
        <para>In the absence of enclosing curly braces, the line immediately after a conditional is the one that is conditionally executed. By both convention and good practice, such lines are indented. In the absence of both curly braces and indentation the intent of the original programmer is entirely unclear and perhaps not actually what is executed. Additionally, such code is highly likely to be confusing to maintainers.</para>
      </section>
      <section>
        <title>S4143: Verify that setting key/index was intended, value has already been set</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0287; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:50:26Z; Modified: 2019-11-02 14:51:46Z.</emphasis>
          </superscript>
        </para>
        <para>SonarLint is able to identify in some situations where indexers are set multiple times to the same value. This would indicate dead code.</para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <screen>variables.Add("X", false);
variables.Add("Y", false);

variables["X"] = false;
variables["Y"] = false;</screen>
      </section>
      <section>
        <title>S4136: Method overloads should be adjacent</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0286; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 14:49:23Z; Modified: 2019-11-02 18:05:55Z.</emphasis>
          </superscript>
        </para>
        <para>When writing code, all methods of the same name with overloads should be adjacent to one another.</para>
        <para>This makes it easier to find code, and functionally should be strongly related to one another.</para>
      </section>
    </section>
    <section>
      <title>Rules for Disablement</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0126; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2016-07-25 21:02:34Z; Modified: 2019-11-02 18:12:54Z.</emphasis>
        </superscript>
      </para>
      <section>
        <title>S101: Rename class to match pascal casing rules</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0240; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 13:32:33Z; Modified: 2019-11-02 13:33:04Z.</emphasis>
          </superscript>
        </para>
        <para>Renaming classes may break API, this should be checked during the code review.</para>
      </section>
      <section>
        <title>S1066: Collapsible "if" statements should be merged</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0204; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 11:27:17Z; Modified: 2019-11-02 11:28:30Z.</emphasis>
          </superscript>
        </para>
        <para>Collapsing if statements may make it more difficult to read the purpose of checks.</para>
        <para>In some instances of code, two if statements may be desirable, if the intended checks are independent of each other.</para>
      </section>
      <section>
        <title>S1168: Return an empty collection instead of null</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0205; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 11:30:33Z; Modified: 2019-11-02 13:01:09Z.</emphasis>
          </superscript>
        </para>
        <para>Code should strive to never return <emphasis role="bold">null</emphasis>, and all code reviews should still consider this a code smell.</para>
        <para>Where code returns <emphasis role="bold">null</emphasis>, it should be considered why, as this can lead to a <emphasis role="bold">NullReferenceException</emphasis>. Instead, code should return an empty collection.</para>
        <para>However, it may not be plausible to return an empty collection when the caller must distinguish between a value empty collection and an error. It is acceptable (and preferred) that a function avoid raising exceptions where ever possible, if it is to be caught internally, and so returning null is in preference of raising exceptions.</para>
        <para>For public API, one should consider instead a Try method that returns false instead of returning null.</para>
        <para>For example</para>
        <screen>if (!myClass.TryGetCollection(out List&lt;string&gt; myList)) {
  // Handle the error
}</screen>
        <para>instead of</para>
        <screen>List&lt;string&gt; myList = myClass.GetCollection();
if (myList == null) {
  // Handle the error
}</screen>
      </section>
      <section>
        <title>S2344: Enumeration type names should not have 'Flags' or 'Enum' suffixes</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0206; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 11:42:48Z; Modified: 2019-11-02 11:43:41Z.</emphasis>
          </superscript>
        </para>
        <para>This rule can be ignored, it doesn't necessarily improve readability.</para>
        <para>Often, code that uses P/Invoke names enumerations as such to be consistent with WinAPI.</para>
      </section>
      <section>
        <title>S2346: Flags enumerations zero-value members should be named 'None'</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0207; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 11:43:50Z; Modified: 2019-11-02 11:45:07Z.</emphasis>
          </superscript>
        </para>
        <para>Often it makes sense to name the zero-value members of an enumeration something else. This is often done in the case of bit fields, where a zero value is equivalent to having a bit disabled (e.g. the default value).</para>
        <para>This rule doesn't necessarily improve readability.</para>
      </section>
      <section>
        <title>S2933: Fields should be "readonly"</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0127; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2016-07-25 21:02:54Z; Modified: 2019-11-02 13:02:20Z.</emphasis>
          </superscript>
        </para>
        <para>This option should be disabled. The recommendation for enabling this rule is to make it clear what objects should be defined in the constructor.</para>
        <para>
          <emphasis role="bold">Dispose</emphasis> methods in framework code often want to set objects to <emphasis role="bold">null</emphasis> so that objects can be collected sooner, in case the user doesn't release the reference to the Framework code immediately. Having <emphasis role="bold">readonly</emphasis> properties makes this not possible.</para>
        <para>The use of <emphasis role="bold">readonly </emphasis>on Visual Studio 2015 U3 has been observed to introduce subtle bugs in the system where fields of a <emphasis role="bold">struct </emphasis>were no longer modifiable (no exception was raised, the debugger showed the value was being updated, but immediately out of context the value was lost resulting in incorrect state).</para>
      </section>
      <section>
        <title>S3217: Explicit conversion of foreach loops should not be used</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0208; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 11:45:16Z; Modified: 2019-11-02 11:51:03Z.</emphasis>
          </superscript>
        </para>
        <para>Code iterating over <emphasis role="bold">foreach </emphasis>loops may define a variable which is different to the <emphasis role="bold">IEnumerable </emphasis>type.</para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <screen>foreach (TraceLineDltBase line in myTraceReaderDlt) {
  // Do something
}</screen>
        <para>The warning will be raised on this, as the object <emphasis role="bold">myTraceReaderDlt </emphasis>implements <emphasis role="bold">IEnumerable&lt;ITraceLine&gt;</emphasis>. If the API stipulates that all objects returned are a derived type, then it is no different to:</para>
        <screen>foreach (ITraceLine readLine in myTraceReaderDlt) {
  TraceLineDltBase line = (TraceLineDltBase)readLine;
  // Do something
}</screen>
        <para>One could argue that this should be written instead</para>
        <screen>foreach (ITraceLine readLine in myTraceReaderDlt) {
  if (readLine is TraceLineDltBase line) {
    // Do something
  }
}</screen>
        <para>but the usage of the <emphasis role="bold">is </emphasis>/ <emphasis role="bold">as </emphasis>operator is slower than a type cast and may be a problem for performance critical code.</para>
        <para>The ultimate solution is to change the object <emphasis role="bold">myTraceReaderDlt </emphasis>to derive instead from <emphasis role="bold">IEnumerable&lt;TraceLineDltBase&gt;</emphasis>, but for some projects this might not be possible.</para>
      </section>
      <section>
        <title>S3626: Jump statements should not be redundant</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0209; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 11:51:09Z; Modified: 2019-11-06 19:24:56Z.</emphasis>
          </superscript>
        </para>
        <para>Code should be reviewed so that unnecessary statements are caught and removed. However, applying this rule religiously may lead to potential maintenance issues when code is copy/pasted (one very common source of error for many programmers).</para>
        <para>If there are a group of <emphasis role="bold">if</emphasis> statements, and the ordering is of no importance, it may be that it is desirable that all blocks use the keyword <emphasis role="bold">return</emphasis>, even if this would be redundant for the last <emphasis role="bold">if</emphasis> block.</para>
        <para>
          <emphasis role="bold">Example</emphasis>:</para>
        <screen>if (x == 0) {
  if (a == 1) {
    StartStateMachine();
    return;
  } else if (a == 2) {
    ProcessInputOne();
    return;
  } else if (a == 3) {
    ProcessInputTwo();
    return;
  }
  
  // We're done
}</screen>
        <para>Any other value results in no change in this function. If for whatever reason a bug fix requires something to be done in the case that the variable <emphasis role="bold">a</emphasis> is not in the range 1, 2, or 3, the developer may add a default case, test it, but not retest the existing cases resulting in the introduction of a bug.</para>
        <para>Reviews should consider this type of code if it can be refactored (e.g. as a <emphasis role="bold">switch </emphasis>statement), but the <emphasis role="bold">return </emphasis>statement is a conscience decision from the developer to tell the reader that the function should end at the location provided.</para>
      </section>
      <section>
        <title>S4070: Non-flag enums should not be marked with FlagsAttribute</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0210; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:01:24Z; Modified: 2019-11-02 12:02:42Z.</emphasis>
          </superscript>
        </para>
        <para>SonarLint often shows this warning, when the intent of the <emphasis role="bold">enum </emphasis>(the values present in the field) are clearly a bit field, even if not used as such.</para>
        <para>Keeping the <emphasis role="bold">FlagsAttribute </emphasis>increases readability at makes it obvious the purpose of the <emphasis role="bold">enum</emphasis>.</para>
      </section>
    </section>
  </section>
  <section>
    <title>Visual Studio 2019 Code Analyzers (v16.3.9)</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0211; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:03:08Z; Modified: 2019-11-15 20:17:13Z.</emphasis>
      </superscript>
    </para>
    <para>The Visual Studio IDE contains many rules implemented within the Roslyn Compiler to identify potential code errors. Many of these rules are being added as replacement for FxCop and other Microsoft analyzers.</para>
    <section>
      <title>Rules Which should not be Ignored</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0220; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:18:31Z; Modified: 2019-11-02 12:18:43Z.</emphasis>
        </superscript>
      </para>
      <section>
        <title>IDE0051: Private member is unused</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0238; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 13:24:56Z; Modified: 2019-11-02 13:25:53Z.</emphasis>
          </superscript>
        </para>
        <para>This applies to private members, methods as well as constants. If the value is private but it is not read.</para>
        <para>The member, method or constant should be removed.</para>
      </section>
      <section>
        <title>IDE0052: Private member can be removed as it's never read</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0233; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:22:45Z; Modified: 2019-11-02 13:26:50Z.</emphasis>
          </superscript>
        </para>
        <para>Private members are assigned to, but are never read.</para>
        <para>This indicates that code was likely refactored and old variables remained behind, and might still be used. Removing these members will simplify code.</para>
      </section>
      <section>
        <title>IDE0059: Unnecessary assignment of variable</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0234; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:22:57Z; Modified: 2019-11-06 19:24:48Z.</emphasis>
          </superscript>
        </para>
        <para>A variable in a function is assigned to, but it is a useless assignment. Keep the variable, but remove the useless assignment.</para>
        <para>
          <emphasis role="bold">Old</emphasis>:</para>
        <screen>FileStream filelock = null;
filelock = new FileStream(fileName);</screen>
        <para>
          <emphasis role="bold">New (fix)</emphasis>:</para>
        <screen>fileStream filelock;
filelock = new FileStream(fileName);</screen>
      </section>
      <section>
        <title>IDE0067: Ensure objects are disposed</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0221; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:18:51Z; Modified: 2019-11-02 13:29:48Z.</emphasis>
          </superscript>
        </para>
        <para>An object is instantiated that implements IDIsposable. That object is never disposed. Dispose the object to fix the warning.</para>
      </section>
      <section>
        <title>IDE0068: Use the recommended dispose pattern to ensure that object is disposed on all paths with a using statement or try/finally</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0222; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:19:07Z; Modified: 2019-11-02 13:31:23Z.</emphasis>
          </superscript>
        </para>
        <para>An object is disposed on some paths, but not all paths.</para>
      </section>
      <section>
        <title>IDE0069: Disposable field is never disposed</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0223; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:19:14Z; Modified: 2019-11-04 19:51:28Z.</emphasis>
          </superscript>
        </para>
        <para>Update the implementation of the class to implement the <emphasis role="bold">IDisposable </emphasis>interface and dispose of the object in the <emphasis role="bold">DIspose </emphasis>method.</para>
        <para>This indicates a probably memory leak.</para>
      </section>
    </section>
    <section>
      <title>Aesthetic Rules which Should be Enabled</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0224; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:19:21Z; Modified: 2019-11-02 12:20:52Z.</emphasis>
        </superscript>
      </para>
      <section>
        <title>IDE0017: Object initialization can be simplified</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0225; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:19:41Z; Modified: 2019-11-06 19:24:26Z.</emphasis>
          </superscript>
        </para>
        <para>Objects should define their properties with the newer syntax</para>
        <para>
          <emphasis role="bold">Old</emphasis>:</para>
        <screen>DltLineConfig config = new DltLineConfig();
config.ApplicationId ="FanControl";
config.EcuId = "MGHI"
config.SessionId = 17;</screen>
        <para>
          <emphasis role="bold">New (preferred)</emphasis>:</para>
        <screen>DltLineConfig config = new DltLineConfig() {
  ApplicationId = "FanControl",
  EcuId = "MGHI",
  SessionId = 17
};</screen>
      </section>
      <section>
        <title>IDE0018: Variable declaration can be Inlined</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0226; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:19:54Z; Modified: 2019-11-06 19:24:17Z.</emphasis>
          </superscript>
        </para>
        <para>Use the new inline feature for defining types. This reduces the amount of whitespace making code more condense and allows the variable to be defined immediately where it is used.</para>
        <para>
          <emphasis role="bold">Old</emphasis>:</para>
        <screen>T item;
if (m_Items.TryGetValue(key, out item)) return item;</screen>
        <para>
          <emphasis role="bold">New (preferred)</emphasis>:</para>
        <screen>if (m_Items.TryGetValue(key out T item)) return item;</screen>
      </section>
      <section>
        <title>IDE0019: Use pattern matching</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0227; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:20:05Z; Modified: 2019-11-06 19:24:09Z.</emphasis>
          </superscript>
        </para>
        <para>Use the new pattern matching feature.</para>
        <para>
          <emphasis role="bold">Rationale</emphasis>:</para>
        <itemizedlist>
          <listitem>
            <para>Makes unused variable usage more obvious</para>
          </listitem>
          <listitem>
            <para>Reduces whitespace in code</para>
          </listitem>
        </itemizedlist>
        <para>
          <emphasis role="bold">Old</emphasis>:</para>
        <screen>ResetFactoryDefaultReq request = service as ResetFactoryDefaultReq;
if (request == null) throw new ArgumentException("Invalid type", nameof(service));</screen>
        <para>
          <emphasis role="bold">New (preferred)</emphasis>:</para>
        <screen>if (!(service is ResetFactoryDefaultReq request)
  throw new ArgumentException("Invalid type", nameof(service));</screen>
        <para>If it turns out that <emphasis role="bold">request </emphasis>is not needed, it can simply be removed.</para>
      </section>
      <section>
        <title>IDE0028: Collection initialization can be simplified</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0228; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:20:12Z; Modified: 2019-11-06 19:24:00Z.</emphasis>
          </superscript>
        </para>
        <para>Initialize the contents of a list while it's being instantiated</para>
        <para>
          <emphasis role="bold">Old</emphasis>:</para>
        <screen>List&lt;string&gt; expressions = new List&lt;string&gt;();
expressions.Add(expression);</screen>
        <para>
          <emphasis role="bold">New (preferred)</emphasis>:</para>
        <screen>List&lt;string&gt; expressions = new List&lt;string&gt;() {
  expression
};</screen>
        <para>As the number of elements being added increase, the code becomes easier to read with less repetition.</para>
      </section>
      <section>
        <title>IDE0029: Null check can be simplfied (null coalescing)</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0229; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:21:02Z; Modified: 2019-11-06 19:23:53Z.</emphasis>
          </superscript>
        </para>
        <para>Use coalescing</para>
        <para>
          <emphasis role="bold">Old</emphasis>:</para>
        <screen>if (handler != null) handler(sender == null ? this : sender, args)</screen>
        <para>
          <emphasis role="bold">New (preferred):</emphasis>
        </para>
        <screen>If (handler != null) handler(sender ?? this, args);</screen>
        <para>Code is shorted, the <emphasis role="bold">?</emphasis>, <emphasis role="bold">??</emphasis> operators are obvious when used in the context of <emphasis role="bold">null</emphasis>.</para>
      </section>
      <section>
        <title>IDE0031: Null check can be simplified (null propagation)</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0230; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:21:11Z; Modified: 2019-11-06 19:23:45Z.</emphasis>
          </superscript>
        </para>
        <para>Use null propagation</para>
        <para>
          <emphasis role="bold">Old</emphasis>:</para>
        <screen>return m_FileName == null ? null : m_FileName.ToString();</screen>
        <para>
          <emphasis role="bold">New (preferred):</emphasis>
        </para>
        <screen>return m_FileName?.ToString();</screen>
      </section>
      <section>
        <title>IDE0041: Null check can be simplified (object is null)</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0231; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:21:21Z; Modified: 2019-11-06 19:23:34Z.</emphasis>
          </superscript>
        </para>
        <para>Instead of using the <emphasis role="bold">object.ReferenceEquals</emphasis>, use the <emphasis role="bold">is</emphasis> operator.</para>
        <para>
          <emphasis role="bold">Old</emphasis>:</para>
        <screen>if (object.ReferenceEquals(null, m_OperationId)) { ... }</screen>
        <para>
          <emphasis role="bold">New (preferred)</emphasis>:</para>
        <screen>if (m_OperationId is null) { ... }</screen>
        <para>Code is shortened and made more readable.</para>
      </section>
      <section>
        <title>IDE0054: Use compound assignment</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0239; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 13:27:03Z; Modified: 2019-11-06 19:23:25Z.</emphasis>
          </superscript>
        </para>
        <para>Reduce the amount of code written, by using compound assignments</para>
        <para>
          <emphasis role="bold">Old</emphasis>:</para>
        <screen>value = value + 4;</screen>
        <para>
          <emphasis role="bold">New (preferred)</emphasis>:</para>
        <screen>value += 4;</screen>
      </section>
    </section>
    <section>
      <title>Rules for Disablement</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0212; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:04:30Z; Modified: 2019-11-02 12:04:33Z.</emphasis>
        </superscript>
      </para>
      <section>
        <title>IDE0016: Null check can be simplified (Exceptions on Null)</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0317; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-06 19:10:04Z; Modified: 2019-11-06 19:23:12Z.</emphasis>
          </superscript>
        </para>
        <para>The rule for detection of the following code</para>
        <para>
          <emphasis role="bold">Preferred</emphasis>:</para>
        <screen>if (entryPoint == null) throw new ArgumentNullException(nameof(entryPoint));
m_Func = entryPoint;</screen>
        <para>to convert to</para>
        <para>
          <emphasis role="bold">New</emphasis>:</para>
        <screen>m_Func = entryPoint ?? throw new ArgumentNullException(nameof(entryPoint));</screen>
        <para>should be disabled.</para>
        <para>
          <emphasis role="bold">Rationale</emphasis>:</para>
        <para>In the case of checking only a single variable, this looks like a benefit. But for the case of checking two or more variables, it may introduce unexpected behavior. A function is expected to check all inputs first <emphasis>before</emphasis> assigning them to module global variables. Doing otherwise may put the object in an unknown/inconsistent state in rare error conditions.</para>
        <para>So preferred is</para>
        <screen>if (entryPoint == null) throw new ArgumentNullException(nameof(entryPoint));
if (description == null) throw new ArgumentNullException(nameof(description));
if (string.IsNullOrEmpty(description)) throw new ArgumentException(nameof(description), "empty!");

m_Func = entryPoint;
m_Description = description;</screen>
      </section>
      <section>
        <title>IDE0034: Simplify 'default' expression</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0213; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:04:34Z; Modified: 2019-11-02 13:03:03Z.</emphasis>
          </superscript>
        </para>
        <para>This is not available in C# 7.0 and so will fail when compiling with Visual Studio 2017. More modern projects should use this if possible.</para>
      </section>
      <section>
        <title>IDE0039: Use local function</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0214; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:05:16Z; Modified: 2019-11-02 12:07:27Z.</emphasis>
          </superscript>
        </para>
        <para>This is not available in C# 7.0 and so will fail when compiling with Visual Studio 2017.</para>
        <para>The usage of lambdas should be used in preference to local functions, to make it obvious the use of anonymous methods.</para>
        <para>Many languages have supported nested classes, multiple inheritance, nested functions. Practice has shown that this is often abused and can lead to difficult to maintain code.</para>
      </section>
      <section>
        <title>IDE0044: Add readonly modifier</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0217; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:13:59Z; Modified: 2019-11-06 19:15:50Z.</emphasis>
          </superscript>
        </para>
        <para>See also S2933</para>
      </section>
      <section>
        <title>IDE0063: Using simple 'using'</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0218; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:14:28Z; Modified: 2019-11-06 19:15:55Z.</emphasis>
          </superscript>
        </para>
        <para>This is not available in C# 7.0 and so will fail when compiling with Visual Studio 2017.</para>
        <para>The new form of specifying <emphasis role="bold">using </emphasis>within a function can significantly reduce nesting. The use of this new form would be encouraged for unit testing only, where the scope of the object is while it is being tested, and should always be disposed before the test case is finished (so as to avoid influencing other test cases running in the test suite).</para>
        <para>For production code, use the existing syntax of <emphasis role="bold">using</emphasis>. This makes it obvious the scope of the object before it is disposed. Simply converting object not disposed to have using without considering each individual case may result in new bugs / regressions.</para>
      </section>
      <section>
        <title>IDE0066: Use 'switch' expressions</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0319; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-06 19:15:43Z; Modified: 2019-11-06 19:20:18Z.</emphasis>
          </superscript>
        </para>
        <para>Prefer the old style switch statements over the newer, more compact versions</para>
        <para>
          <emphasis role="bold">Preferred</emphasis>:</para>
        <screen>if (window != ProcessWindow.Default) {
  si.dwFlags |= NativeMethods.STARTF.STARTF_USESHOWWINDOW;
  switch (window) {
  case ProcessWindow.Hide:
    si.wShowWindow = NativeMethods.ShowState.SW_HIDE;
    break;
  case ProcessWindow.Maximize:
    si.wShowWindow = NativeMethods.ShowState.SW_SHOWMAXIMIZED;
    break;
  case ProcessWindow.Minimize:
    si.wShowWindow = NativeMethods.ShowState.SW_SHOWMINIMIZED;
    break;
  default:
    si.wShowWindow = NativeMethods.ShowState.SW_SHOWNORMAL;
    break;
  }
}</screen>
        <para>
          <emphasis role="bold">New</emphasis>:</para>
        <screen>if (window != ProcessWindow.Default) {
  si.dwFlags |= NativeMethods.STARTF.STARTF_USESHOWWINDOW;
  si.wShowWindow = window switch {
    ProcessWindow.Hide =&gt; NativeMethods.ShowState.SW_HIDE,
    ProcessWindow.Maximize =&gt; NativeMethods.ShowState.SW_SHOWMAXIMIZED,
    ProcessWindow.Minimize =&gt; NativeMethods.ShowState.SW_SHOWMINIMIZED,
    _ =&gt; NativeMethods.ShowState.SW_SHOWNORMAL,
  };
}</screen>
        <para>The newer style is compact. In this example, it may be easier to read, but extending functionality can be tedious and introduce errors.</para>
        <para>Secondly, the <emphasis role="bold">default </emphasis>case, which is known to almost all programmers familiar with other languages such as C, C++, won't necessarily know what the discard case is '<emphasis role="bold">_</emphasis>'. Thus, the new style is more difficult to read and maintain.</para>
      </section>
      <section>
        <title>IDE1005: Event Handler Invocation can be simplified</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0320; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-06 19:20:32Z; Modified: 2019-11-06 19:22:47Z.</emphasis>
          </superscript>
        </para>
        <para>Prefer the old style, since C# 4.0, over the new nullable style.</para>
        <para>
          <emphasis role="bold">Preferred</emphasis>:</para>
        <screen>protected void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs args) {
  NotifyCollectionChangedEventHandler handler = CollectionChanged;
  if (handler != null) handler(sender, args);
}</screen>
        <para>
          <emphasis role="bold">New</emphasis>:</para>
        <screen>CollectionChanged?.Invoke(sender, args);</screen>
        <para>
          <emphasis role="bold">Rationale</emphasis>:</para>
        <para>The first style is similar to how other languages, such as C and C++ are written for function pointers and callbacks, so is easier for those developers to read and understand the code that is being done.</para>
        <para>For the newer case, there's an <emphasis role="bold">Invoke()</emphasis>, which is a method for delegates, but changes the readability from the first case.</para>
      </section>
      <section>
        <title>IDE1006: Naming Styles</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0219; Author: Jason Curl &lt;jcurl@arcor.de&gt;; Status: Proposed; Version: 1.0; Created: 2019-11-02 12:17:34Z; Modified: 2019-11-02 12:18:13Z.</emphasis>
          </superscript>
        </para>
        <para>Often projects have reasons for using a different naming style, or legacy code. Enabling this message may result in a lot of false positives, making it more difficult to find real issues.</para>
      </section>
    </section>
  </section>
  <section>
    <title>Code Analysis: Mandatory Ruleset (Microsoft Managed Recommended Rules)</title>
    <para>
      <superscript>
        <emphasis>Requirement: CREQ0120; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2016-07-25 20:54:10Z; Modified: 2019-11-02 11:25:17Z.</emphasis>
      </superscript>
    </para>
    <para>The set of rules defined by Microsoft Managed Recommended Rules shall be mandatory for all projects. This can be accessed via the project properties under the section "Code Analysis". Additional rules may be specified.</para>
    <section>
      <title>Microsoft Binary Analysis (Mid-High)</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0114; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-06-13 09:41:32Z; Modified: 2016-07-25 20:58:49Z.</emphasis>
        </superscript>
      </para>
      <para>The CodeAnalysis plugin is available with paid versions of Microsoft Visual Studio as well as the Community Editions.</para>
      <para>CodeAnalysis is a lint tool that highlights common errors based on Microsoft Coding Guidelines.</para>
      <para>It is found in the menu Analyze -&gt; Run CodeAnalysis on Solution.</para>
      <para>Below are some common error codes considered as a problem during development, but by no means all. Each error code should be analysed on a case-by-case basis and determined if it is a problem or not. Almost all issues are considered an issue and should be fixed.</para>
      <section>
        <title>Some Rules and their Rationale</title>
        <para>
          <superscript>
            <emphasis>Requirement: CREQ0128; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2016-07-25 21:07:14Z; Modified: 2016-07-25 21:07:26Z.</emphasis>
          </superscript>
        </para>
        <section>
          <title>CA1065: Do not raise exceptions in unexpected locations</title>
          <para>
            <superscript>
              <emphasis>Requirement: CREQ0115; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 08:09:13Z; Modified: 2016-07-25 21:07:29Z.</emphasis>
            </superscript>
          </para>
        </section>
        <section>
          <title>CA1404: Call GetLastError immediately after P/Invoke</title>
          <para>
            <superscript>
              <emphasis>Requirement: CREQ0116; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 08:13:55Z; Modified: 2016-07-25 21:07:30Z.</emphasis>
            </superscript>
          </para>
          <para>It is important that Marshal.GetLastWin32Error() is called immediately after a P/Invoke, so that the error code determined is well defined, not based on any other function call.</para>
        </section>
        <section>
          <title>CA2213: Disposable fields should be disposed</title>
          <para>
            <superscript>
              <emphasis>Requirement: CREQ0117; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 08:10:40Z; Modified: 2016-07-25 21:07:31Z.</emphasis>
            </superscript>
          </para>
        </section>
        <section>
          <title>CA2214: Do not call overridable methods in constructors</title>
          <para>
            <superscript>
              <emphasis>Requirement: CREQ0118; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2015-11-10 08:11:11Z; Modified: 2016-07-25 21:07:32Z.</emphasis>
            </superscript>
          </para>
          <para>A constructor should not call a virtual method from itself, as this can lead to undefined behaviour for derived classes. Refactoring/Redesign of the class is required.</para>
          <para>If a derived class overrides the virtual method, and that virtual method then depends on variables of the derived class, its behaviour is undefined. That is because of the order in which the constructors are called.</para>
          <para>The base class constructor is called first, which if then uses a virtual method, is executed on a class whose constructor has not yet been called, thus resulting in undefined behaviour.</para>
        </section>
      </section>
    </section>
    <section>
      <title>Microsoft.CodeAnalysis.CSharp</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0122; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2016-07-25 20:59:18Z; Modified: 2016-07-25 21:00:55Z.</emphasis>
        </superscript>
      </para>
      <para>All options under this code analysis section should be enabled (part of Microsoft Managed Recommended Rules).</para>
    </section>
    <section>
      <title>Microsoft.CodeAnalysis.CSharp.EditorFeatures</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0123; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2016-07-25 20:59:48Z; Modified: 2016-07-25 21:00:58Z.</emphasis>
        </superscript>
      </para>
      <para>All options under this code analysis section should be enabled (part of Microsoft Managed Recommended Rules).</para>
    </section>
    <section>
      <title>Microsoft.CodeAnalysis.CSharp.Features</title>
      <para>
        <superscript>
          <emphasis>Requirement: CREQ0124; Author: jcurl; Status: Proposed; Version: 1.0; Created: 2016-07-25 21:00:10Z; Modified: 2016-07-25 21:01:03Z.</emphasis>
        </superscript>
      </para>
      <para>All options under this code analysis section should be enabled (part of Microsoft Managed Recommended Rules).</para>
    </section>
  </section>
</chapter>